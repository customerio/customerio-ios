require 'json'
require 'xcodeproj'

# Fastfile that is meant to be used by all iOS apps in the organization. 
# This file is meant to be imported into another `Fastfile` so the functions in this file are usable. 
# 
# Import this file in 2 ways:
# 1. Locally (for all Fastfile files in this repository) using "import" (https://docs.fastlane.tools/advanced/Fastfile/#importing-another-fastfile)
# ```
# import "../../fastlane/Fastfile"
# ```
#
# 2. Remotely (for all Fastfile files in a git repository not this one)
# Add this to your Fastfile:
# ```
# import_from_git(
#  url: "https://github.com/customerio/customerio-ios.git",
#  branch: "main", # The branch to checkout on the repository.
#  path: "Apps/fastlane/Fastfile" # The path of the Fastfile in the repository.
# )
# ```

# Functions for setting up code signing on CI server 
import_from_git(
  url: "https://github.com/customerio/apple-code-signing.git", 
  branch: "main", 
  path: "fastlane/Fastfile"
)

before_all do |lane, options|    
  setup_ci
end

lane :build do
  download_ci_code_signing_files
  
  new_app_version = ""
  release_notes = []
  groups = ['all-builds'] # default - always send to these groups. 

  # This code is only used for stable builds made when a git tag is made. However, it would be convenient to test this code 
  # more often then just when a git tag is created. Code executes here and values are overriden on pull request builds. 
  sh('git fetch --tags') # Workaround for last_git_tag action. Learn more: https://docs.fastlane.tools/actions/last_git_tag/
  new_app_version = last_git_tag # default is to use latest git tag created on branch. Variable overriden later on. 

  github_actions_metadata_path = ENV["GITHUB_EVENT_PATH"]
  UI.message("GitHub Action metadata file path located: #{github_actions_metadata_path}")  

  github = GitHub.new(JSON.parse(File.open(github_actions_metadata_path).read))

  new_build_number = github.commit_hash

  if github.is_pull_request
    UI.message("I see this is a pull request. Build metadata will include helpful PR info.")

    new_app_version = github.source_branch

    release_notes.append(
      "build type: pull request",
      "pr title: #{github.pr_title}",
      "pr number: #{github.pr_number}",
      "pr author: #{github.author}",
      "source branch: #{github.source_branch}",
      "destination branch: #{github.destination_branch}"
    )
  elsif github.is_push # builds when a git tag is made. 
    UI.message("Deploying a stable build of app. Version: #{new_app_version}")
    
    groups.append("stable-builds")

    release_notes.append(
      "build type: release",
      "version: #{new_app_version}"
    )
  else 
    UI.message("This is not a pull request or push. Going to ignore the event.")        
    return 
  end

  release_notes.append(      
    "commit hash: #{github.commit_hash}"
  )

  release_notes = release_notes.join("\n")
  groups = groups.join(", ")

  UI.important("Release notes:\n#{release_notes}")
  UI.important("New app version: #{new_app_version}")
  UI.important("New app build number: #{new_build_number}")
  UI.important("Firebase App testing groups: #{groups}")

  update_app_versions(
    build_number: new_build_number,
    app_version: new_app_version
  )

  uses_cocoapods = File.exists?("../Podfile")
  if uses_cocoapods 
    UI.message "Project uses CocoaPods. Going to skip SPM dependency downloading."
  end 
  
  # prevents builds from being flaky. As app sizese get bigger, it takes fastlane longer to initialize the build process. Increase this value to compensate for that. 
  ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "10" 
  build_ios_app(
    export_method: "ad-hoc",
    configuration: "Release",
    clean: true, # Problems have occurred in the past on CI server with derived data. Clean project before building to avoid these issues. 
    xcodebuild_formatter: "xcbeautify",
    disable_package_automatic_updates: true, # force SPM dependencies to install from Package.resolved lock file
    skip_package_dependencies_resolution: uses_cocoapods, # If using CocoaPods, skip SPM dependency downloading to save build time
  )

  service_credentials_file_path = setup_google_bucket_access(
    environment_variable_key: "FIREBASE_APP_DISTRIBUTION_SERVICE_ACCOUNT_CREDS_B64"
  )
  
  firebase_app_distribution(
    service_credentials_file: service_credentials_file_path,
    groups: groups,
    release_notes: release_notes
  )
end

lane :update_app_versions do |arguments| 
  new_build_number = arguments[:build_number]
  new_app_version = arguments[:app_version]

  # We need to update the app before building with the new version and build numbers. This makes builds easier to find by team members and install them onto devices. 
  # This is usually done by updating Info.plist files. But Xcode 13 removed Info.plist files and made it part of the xcode project. 
  # Therefore, we attempt both methods to update the version numbers. 
  # Here, we try to update Info.plist files. 
  Dir.glob("../**/Info.plist").each { |plist_file_path| 
    plist_file_path = File.expand_path(plist_file_path, Dir.pwd)
    UI.message("Found Info.plist file #{plist_file_path} to update versions for.")

    # We only want to modify a value in plist file and not add a new value if it doesn't exist in the file yet. 
    # Therefore, check if a value already exists and it if does, then set a new value. 
    if !get_info_plist_value(path: plist_file_path, key: "CFBundleVersion").nil? 
      UI.message("Build version exists in plist file. Going to set new value")
      set_info_plist_value(path: plist_file_path, key: "CFBundleVersion", value: new_build_number) 
    end 

    if !get_info_plist_value(path: plist_file_path, key: "CFBundleShortVersionString").nil? 
      UI.message("Build version string exists in plist file. Going to set new value")
      set_info_plist_value(path: plist_file_path, key: "CFBundleShortVersionString", value: new_app_version)
    end 
  }

  # Here, we try to update the xcode project settings. 
  project_path = Dir.glob("../*.xcodeproj").first
  project_path = File.expand_path(project_path, Dir.pwd)
  UI.message("Using found Xcode project path: #{project_path}")
  project = Xcodeproj::Project.open(project_path)
  project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['MARKETING_VERSION'] = new_app_version
      config.build_settings['CURRENT_PROJECT_VERSION'] = new_build_number
    end
  end
  project.save  
end 

# Parse JSON out of GitHub Context JSON when being executed on GitHub Actions. 
class GitHub 
  # `event` payload for pushes: https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#push
  # `event` payload for pull requests: https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request

  def initialize(github_context)
    @github_context = github_context
  end 

  def is_push 
    @github_context["commits"] != nil 
  end 

  def is_pull_request
    @github_context["pull_request"] != nil 
  end 

  def commit_hash
    if is_push
      return @github_context["head_commit"]["id"][0..8]
    else 
      return @github_context["pull_request"]["head"]["sha"][0..8]
    end 
  end

  def pr_title 
    @github_context["pull_request"]["title"]
  end 

  def pr_number
    @github_context["pull_request"]["number"]
  end 

  def source_branch
    if is_push
      return ""
    else 
      return @github_context["pull_request"]["head"]["ref"]
    end 
  end 

  def destination_branch
    if is_push
      return ""
    else 
      return @github_context["pull_request"]["base"]["ref"]
    end 
  end 

  def author 
    if is_push 
      return @github_context["head_commit"]["committer"]["username"]      
    else 
      return @github_context["pull_request"]["user"]["login"]
    end 
  end 
end 
