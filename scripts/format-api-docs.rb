#!/usr/bin/env ruby

require 'json'

class SwiftApiFormatter
  def initialize(input_file)
    @input_file = input_file
    @data = JSON.parse(File.read(input_file))
  rescue JSON::ParserError => e
    puts "Error reading JSON file: #{e.message}"
    exit(1)
  rescue => e
    puts "Error reading file: #{e.message}"
    exit(1)
  end

  def format_output
    classes = extract_all_classes
    classes.sort_by! { |cls| cls[:name] }
    
    classes.each do |class_info|
      puts format_class_output(class_info)
    end
  end

  private

  def extract_all_classes
    classes = []
    
    @data.each do |file_data|
      file_data.each do |file_path, file_info|
        # Skip files in autogenerated directories (contains mocks and generated code)
        next if file_path.include?('/autogenerated/')
        
        substructure = file_info['key.substructure'] || []
        substructure.each do |structure|
          class_info = extract_class_info(structure)
          classes << class_info if class_info
        end
      end
    end
    
    classes
  end

  def extract_class_info(structure)
    return nil unless structure['key.kind']
    
    kind = structure['key.kind']
    return nil unless %w[
      source.lang.swift.decl.class
      source.lang.swift.decl.struct  
      source.lang.swift.decl.protocol
      source.lang.swift.decl.enum
    ].include?(kind)
    
    name = structure['key.name'] || ''
    module_name = structure['key.modulename'] || ''
    accessibility = structure['key.accessibility'] || ''
    
    # Only include public APIs
    return nil unless accessibility.include?('public')
    
    full_name = module_name.empty? ? name : "#{module_name}.#{name}"
    
    class_info = {
      name: full_name,
      kind: kind.split('.').last,
      methods: [],
      fields: []
    }
    
    # Process substructure (methods, properties, etc.)
    substructure = structure['key.substructure'] || []
    substructure.each do |item|
      process_member(item, class_info)
    end
    
    class_info
  end

  def process_member(member, class_info)
    kind = member['key.kind'] || ''
    accessibility = member['key.accessibility'] || ''
    
    # Only process public members
    return unless accessibility.include?('public')
    
    if kind.include?('function')
      # Method
      method_sig = extract_method_signature(member)
      class_info[:methods] << method_sig if method_sig
    elsif kind.include?('var')
      # Property/Field
      field_sig = extract_field_signature(member)
      class_info[:fields] << field_sig if field_sig
    end
  end

  def extract_method_signature(method)
    name = method['key.name'] || ''
    parsed_decl = method['key.parsed_declaration'] || ''
    
    return nil if name.empty? || parsed_decl.empty?
    
    # Clean up the declaration
    cleaned = parsed_decl.dup
    cleaned.gsub!(/@discardableResult\s+/, '')
    cleaned.gsub!(/public\s+/, '')
    cleaned.gsub!(/static\s+/, '')
    cleaned.gsub!(/final\s+/, '')
    
    # Convert Swift syntax to more generic format
    cleaned = convert_swift_types(cleaned)
    
    "public fun #{cleaned}"
  end

  def extract_field_signature(field)
    name = field['key.name'] || ''
    typename = field['key.typename'] || ''
    parsed_decl = field['key.parsed_declaration'] || ''
    
    return nil if name.empty?
    
    # Convert Swift types to generic format
    converted_type = typename.empty? ? 'Any' : convert_swift_types(typename)
    
    if parsed_decl.include?('let')
      "public final val #{name}: #{converted_type}"
    else
      "public var #{name}: #{converted_type}"
    end
  end

  def convert_swift_types(type_str)
    # Basic type conversions
    conversions = {
      'String' => 'String',
      'Int' => 'Int', 
      'Bool' => 'Boolean',
      'Double' => 'Double',
      'Float' => 'Float',
      'Void' => 'Unit',
      'Any' => 'Any',
      '[String : Any]' => 'Map<String, Any>',
      'URL' => 'URL'
    }
    
    result = type_str.dup
    conversions.each do |swift_type, generic_type|
      result.gsub!(swift_type, generic_type)
    end
    
    # Handle optionals
    result.gsub!('?', '?')
    
    # Handle arrays
    result.gsub!(/\[([^\]]+)\]/, 'List<\1>')
    
    result
  end

  def format_class_output(class_info)
    lines = []
    
    kind_map = {
      'class' => 'class',
      'struct' => 'class',  # Treat structs as classes
      'protocol' => 'interface', 
      'enum' => 'enum'
    }
    
    kind = kind_map[class_info[:kind]] || 'class'
    modifier = kind == 'class' ? 'public final' : 'public'
    
    # Class declaration
    lines << "#{modifier} #{kind} #{class_info[:name]} {"
    
    # Fields
    class_info[:fields].each do |field|
      lines << "\t#{field};"
    end
    
    # Methods
    class_info[:methods].each do |method|
      lines << "\t#{method};"
    end
    
    lines << "}"
    lines << "" # Empty line between classes
    
    lines.join("\n")
  end
end

# Main execution
if ARGV.length != 1
  puts "Usage: ruby format_api.rb <input_json_file>"
  exit(1)
end

input_file = ARGV[0]

unless File.exist?(input_file)
  puts "Error: File '#{input_file}' does not exist"
  exit(1)
end

formatter = SwiftApiFormatter.new(input_file)
formatter.format_output 