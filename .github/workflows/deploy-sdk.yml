name: Deploy SDK

on:
  workflow_dispatch: # manually run this workflow. This allows you to manually deploy things like cococapods, not manually create a git tag. The tag needs to already be created to run this.
    inputs:
      existing-git-tag:
        description: 'Type name of existing git tag (example: 1.0.3) to checkout and manually deploy'
        required: true
        type: string

  push:
    branches: [beta, main, ahmed/ci/sem_release] # all branches where deployments currently occur. Make sure this list matches list of branches in  `.releaserc` file.

permissions:
  contents: write # access to push the git tag

jobs:
  # We can only generate SDK size reports on macOS and we prefer to run deployments on Linux because macOS resources are limited. 
  # Therefore, generating SDK reports is a separate job that runs before deployment.
 
  # Check if we should skip this workflow run
  check-skip:
    name: Check if workflow should be skipped
    runs-on: ubuntu-latest
    outputs:
      should_skip: ${{ steps.check.outputs.should_skip }}
    steps:
      - id: check
        name: Check for skip conditions
        run: |
          # Check if commit message contains [skip ci] or was created by our workflow
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # Get the commit message - this requires checkout first
            git clone --quiet --no-checkout --filter=blob:none --depth=1 https://github.com/${{ github.repository }}.git .
            COMMIT_MSG=$(git log --format=%B -n 1 ${{ github.sha }})
            echo "Commit message: $COMMIT_MSG"
            
            # Skip if [skip ci] or workflow commit message pattern is found
            if [[ "$COMMIT_MSG" == *"[skip ci]"* ]] || [[ "$COMMIT_MSG" == *"[CI WORKFLOW]"* ]] || [[ "$COMMIT_MSG" == "chore: prepare for"* ]]; then
              echo "This is a workflow-generated commit or has [skip ci] tag. Skipping workflow run."
              echo "should_skip=true" >> $GITHUB_OUTPUT
            else
              echo "Regular commit, continuing with workflow."
              echo "should_skip=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Not a push event, continuing with workflow."
            echo "should_skip=false" >> $GITHUB_OUTPUT
          fi

  deploy-git-tag:
    name: Deploy git tag
    needs: [check-skip]
    if: ${{ needs.check-skip.outputs.should_skip != 'true' }}
    runs-on: ubuntu-latest
    outputs:
      new_release_git_head: ${{ steps.semantic-release.outputs.new_release_git_head }}
      new_release_published: ${{ steps.semantic-release.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic-release.outputs.new_release_version }}
      tag_pushed: ${{ steps.tag-verification.outputs.tag_pushed }}
    steps:
      - uses: actions/checkout@v4
        with:
          # We need full history and tags for semantic-release to work properly
          fetch-depth: 0
          
      # Configure Git for semantic-release
      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions"

      # CLI to replace strings in files. The CLI recommends using `cargo install` which is slow. This Action is fast because it downloads pre-built binaries.
      # If using sd on macos, "brew install" works great. for Linux, this is the recommended way.
      - name: Install sd CLI to use later in the workflow
        # uses: kenji-miyake/setup-sd@59a1bd7bba077f6c491f04cd9d24b524ea2db4b6 # v1.1.1
        uses: levibostian/setup-sd@cbdeed93d4fe03f9e36b73bb6d9e7c3c4805e1f9 # add-file-extension # Using fork until upstream Action has bug fixed in it.
   
          
      - name: 'Generate token'
        id: generate_token
        uses: tibdex/github-app-token@3beb63f4bd073e61482598c45c71c1019b59b73a # v2.1.0
        with:
          app_id: ${{ secrets.CIO_APP_ID }}
          private_key: ${{ secrets.CIO_APP_SECRET }}
          
      - name: Setup repository with token
        run: |
          # Configure git to use the token for authentication
          git config --global credential.helper store
          echo "https://x-access-token:${{ steps.generate_token.outputs.token }}@github.com" > ~/.git-credentials
          chmod 600 ~/.git-credentials
          
          # Verify current remote URL
          echo "Current remotes:"
          git remote -v
          
          # Test authentication with token
          echo "Testing token authentication..."
          git ls-remote --exit-code --heads origin main || echo "Authentication failed!"
          
          # Verify GitHub App permissions
          echo "Verifying GitHub App permissions via API..."
          curl -s -H "Authorization: token ${{ steps.generate_token.outputs.token }}" \
               -H "Accept: application/vnd.github.v3+json" \
               "https://api.github.com/installation/repositories" | grep -q "${{ github.repository }}" && \
               echo "✅ GitHub App has access to this repository" || \
               echo "❌ GitHub App might not have proper repository access"
    
      # Semantic-release tool is used to:
      # 1. Determine the next semantic version for the software during deployment.
      #    For example, if the last deployment you made was version 1.3.5 and you are releasing a new feature
      #    in this deployment, semantic release will automatically determine the version is 1.4.0 for this new release you're doing.
      #    Semantic release is able to do this by viewing commit messages since the last release. That's why this project uses a
      #    specific commit message format during pull requests.
      # 2. Updates metadata files. Such as updating the version number in package.json and adding entries to CHANGELOG.md file.
      # 3. Create git tag and push it to github.
      # Debug GitHub token permissions
      - name: Debug token permissions
        run: |
          echo "Token check: Using GitHub App token - Making sure it exists"
          if [ -n "${{ steps.generate_token.outputs.token }}" ]; then
            echo "GitHub App token is present"
            echo "Token first 5 chars: ${TOKEN:0:5}..."
          else
            echo "ERROR: GitHub App token is missing!"
          fi
          
          # Output Git and GitHub configuration
          echo "Current Git Configuration:"
          git config --list
        env:
          TOKEN: ${{ steps.generate_token.outputs.token }}
          
      - name: Deploy git tag via semantic-release
        uses: cycjimmy/semantic-release-action@0a51e81a6baff2acad3ee88f4121c589c73d0f0e # v4.2.0
        id: semantic-release
        with:
          # version numbers below can be in many forms: M, M.m, M.m.p
          # version should be greater than the 22.0.1 (https://github.com/semantic-release/semantic-release/releases/tag/v22.0.1)
          # because previous version had a bug in commit analyzer
          semantic_version: latest
          extra_plugins: |
            conventional-changelog-conventionalcommits@8
            @semantic-release/github
            @semantic-release/exec
        env:
          # Needs to push git commits to repo. Needs write access.
          GITHUB_TOKEN: ${{ steps.generate_token.outputs.token }}
          
      # Verify tag was properly created and pushed
      - name: Verify tag creation
        id: tag-verification
        if: steps.semantic-release.outputs.new_release_published == 'true'
        run: |
          if [ -n "${{ steps.semantic-release.outputs.new_release_version }}" ]; then
            echo "Verifying tag ${{ steps.semantic-release.outputs.new_release_version }} exists remotely..."
            
            # Check if tag exists remotely
            if git ls-remote --tags origin "refs/tags/${{ steps.semantic-release.outputs.new_release_version }}" | grep -q "${{ steps.semantic-release.outputs.new_release_version }}"; then
              echo "✅ Tag ${{ steps.semantic-release.outputs.new_release_version }} successfully verified on remote!"
              echo "tag_pushed=true" >> $GITHUB_OUTPUT
            else
              echo "⚠️ Tag not found on remote, attempting to repair..."
              
              # Try to repair by re-pushing the tag
              git fetch --tags
              
              if git show-ref --tags "${{ steps.semantic-release.outputs.new_release_version }}" --quiet; then
                echo "Tag exists locally, pushing again..."
                git push --force origin "refs/tags/${{ steps.semantic-release.outputs.new_release_version }}"
                
                # Verify again
                if git ls-remote --tags origin "refs/tags/${{ steps.semantic-release.outputs.new_release_version }}" | grep -q "${{ steps.semantic-release.outputs.new_release_version }}"; then
                  echo "✅ Tag successfully repaired and pushed!"
                  echo "tag_pushed=true" >> $GITHUB_OUTPUT
                else
                  echo "❌ Failed to repair tag."
                  echo "tag_pushed=false" >> $GITHUB_OUTPUT
                fi
              else
                echo "❌ Tag not found locally either."
                echo "tag_pushed=false" >> $GITHUB_OUTPUT
              fi
            fi
          else
            echo "No new version was released."
            echo "tag_pushed=false" >> $GITHUB_OUTPUT
          fi