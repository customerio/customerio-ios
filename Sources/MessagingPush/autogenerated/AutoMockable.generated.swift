// Generated using Sourcery 2.0.3 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT
// swiftlint:disable all

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif
#if canImport(UserNotifications)
import UserNotifications
#endif
import CioInternalCommon

/**
######################################################
Documentation
######################################################

This automatically generated file you are viewing contains mock classes that you can use in your test suite. 

* How do you generate a new mock class? 

1. Mocks are generated from Swift protocols. So, you must make one. 

```
protocol FriendsRepository {
    func acceptFriendRequest<Attributes: Encodable>(attributes: Attributes, _ onComplete: @escaping () -> Void)
}

class AppFriendsRepository: FriendsRepository {
    ...
}
```

2. Have your new protocol extend `AutoMockable`:

```
protocol FriendsRepository: AutoMockable {
    func acceptFriendRequest<Attributes: Encodable>(
        // sourcery:Type=Encodable
        attributes: Attributes, 
        _ onComplete: @escaping () -> Void)
}
```

> Notice the use of `// sourcery:Type=Encodable` for the generic type parameter. Without this, the mock would 
fail to compile: `functionNameReceiveArguments = (Attributes)` because `Attributes` is unknown to this `var`. 
Instead, we give the parameter a different type to use for the mock. `Encodable` works in this case. 
It will require a cast in the test function code, however. 

3. Run the command `make generate` on your machine. The new mock should be added to this file. 

* How do you use the mocks in your test class? 

```
class ExampleViewModelTest: XCTestCase {
    var viewModel: ExampleViewModel!
    var exampleRepositoryMock: ExampleRepositoryMock!
    override func setUp() {
        exampleRepositoryMock = ExampleRepositoryMock()
        viewModel = AppExampleViewModel(exampleRepository: exampleRepositoryMock)
    }
}
```

Or, you may need to inject the mock in a different way using the DI.shared graph:

```
class ExampleTest: XCTestCase {
    var exampleViewModelMock: ExampleViewModelMock!
    var example: Example!
    override func setUp() {
        exampleViewModelMock = ExampleViewModelMock()
        DI.shared.override(.exampleViewModel, value: exampleViewModelMock, forType: ExampleViewModel.self)
        example = Example()
    }
}

```

*/















/**
 Class to easily create a mocked version of the `AutomaticPushClickHandling` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
@available(iOSApplicationExtension, unavailable)
internal class AutomaticPushClickHandlingMock: AutomaticPushClickHandling, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    internal var mockCalled: Bool = false // 

    internal init() {
        Mocks.shared.add(mock: self)
    }


    public func resetMock() {
        startCallsCount = 0

        self.mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - start

    /// Number of times the function was called.  
    @Atomic internal private(set) var startCallsCount = 0
    /// `true` if the function was ever called. 
    internal var startCalled: Bool {
        return startCallsCount > 0
    }    
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var startClosure: (() -> Void)?

    /// Mocked function for `start()`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func start() {
        self.mockCalled = true
        startCallsCount += 1
        startClosure?()
    }

}
/**
 Class to easily create a mocked version of the `MessagingPushInstance` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
public class MessagingPushInstanceMock: MessagingPushInstance, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    public var mockCalled: Bool = false // 

    public init() {
        Mocks.shared.add(mock: self)
    }


    public func resetMock() {
        registerDeviceTokenCallsCount = 0
        registerDeviceTokenReceivedArguments = nil 
        registerDeviceTokenReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        deleteDeviceTokenCallsCount = 0

        self.mockCalled = false // do last as resetting properties above can make this true
        trackMetricCallsCount = 0
        trackMetricReceivedArguments = nil 
        trackMetricReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
    #if canImport(UserNotifications)
        didReceiveNotificationRequestCallsCount = 0
        didReceiveNotificationRequestReceivedArguments = nil 
        didReceiveNotificationRequestReceivedInvocations = []
    #endif 

        self.mockCalled = false // do last as resetting properties above can make this true
    #if canImport(UserNotifications)
        serviceExtensionTimeWillExpireCallsCount = 0
    #endif 

        self.mockCalled = false // do last as resetting properties above can make this true
    #if canImport(UserNotifications)
        userNotificationCenter_withCompletionCallsCount = 0
        userNotificationCenter_withCompletionReceivedArguments = nil 
        userNotificationCenter_withCompletionReceivedInvocations = []
    #endif 

        self.mockCalled = false // do last as resetting properties above can make this true
    #if canImport(UserNotifications)
        userNotificationCenterCallsCount = 0
        userNotificationCenterReceivedArguments = nil 
        userNotificationCenterReceivedInvocations = []
    #endif 

        self.mockCalled = false // do last as resetting properties above can make this true
        getConfigurationCallsCount = 0

        self.mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - registerDeviceToken

    /// Number of times the function was called.  
    @Atomic public private(set) var registerDeviceTokenCallsCount = 0
    /// `true` if the function was ever called. 
    public var registerDeviceTokenCalled: Bool {
        return registerDeviceTokenCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic public private(set) var registerDeviceTokenReceivedArguments: (String)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic public private(set) var registerDeviceTokenReceivedInvocations: [(String)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    public var registerDeviceTokenClosure: ((String) -> Void)?

    /// Mocked function for `registerDeviceToken(_ deviceToken: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func registerDeviceToken(_ deviceToken: String) {
        self.mockCalled = true
        registerDeviceTokenCallsCount += 1
        registerDeviceTokenReceivedArguments = (deviceToken)
        registerDeviceTokenReceivedInvocations.append((deviceToken))
        registerDeviceTokenClosure?(deviceToken)
    }

    // MARK: - deleteDeviceToken

    /// Number of times the function was called.  
    @Atomic public private(set) var deleteDeviceTokenCallsCount = 0
    /// `true` if the function was ever called. 
    public var deleteDeviceTokenCalled: Bool {
        return deleteDeviceTokenCallsCount > 0
    }    
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    public var deleteDeviceTokenClosure: (() -> Void)?

    /// Mocked function for `deleteDeviceToken()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func deleteDeviceToken() {
        self.mockCalled = true
        deleteDeviceTokenCallsCount += 1
        deleteDeviceTokenClosure?()
    }

    // MARK: - trackMetric

    /// Number of times the function was called.  
    @Atomic public private(set) var trackMetricCallsCount = 0
    /// `true` if the function was ever called. 
    public var trackMetricCalled: Bool {
        return trackMetricCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic public private(set) var trackMetricReceivedArguments: (deliveryID: String, event: Metric, deviceToken: String)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic public private(set) var trackMetricReceivedInvocations: [(deliveryID: String, event: Metric, deviceToken: String)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    public var trackMetricClosure: ((String, Metric, String) -> Void)?

    /// Mocked function for `trackMetric(deliveryID: String, event: Metric, deviceToken: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func trackMetric(deliveryID: String, event: Metric, deviceToken: String) {
        self.mockCalled = true
        trackMetricCallsCount += 1
        trackMetricReceivedArguments = (deliveryID: deliveryID, event: event, deviceToken: deviceToken)
        trackMetricReceivedInvocations.append((deliveryID: deliveryID, event: event, deviceToken: deviceToken))
        trackMetricClosure?(deliveryID, event, deviceToken)
    }

    // MARK: - didReceive

    #if canImport(UserNotifications)
    /// Number of times the function was called.  
    @Atomic public private(set) var didReceiveNotificationRequestCallsCount = 0
    /// `true` if the function was ever called. 
    public var didReceiveNotificationRequestCalled: Bool {
        return didReceiveNotificationRequestCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic public private(set) var didReceiveNotificationRequestReceivedArguments: (request: UNNotificationRequest, contentHandler: (UNNotificationContent) -> Void)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic public private(set) var didReceiveNotificationRequestReceivedInvocations: [(request: UNNotificationRequest, contentHandler: (UNNotificationContent) -> Void)] = []
    /// Value to return from the mocked function. 
    public var didReceiveNotificationRequestReturnValue: Bool!
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`, 
     then the mock will attempt to return the value for `didReceiveNotificationRequestReturnValue`
     */
    public var didReceiveNotificationRequestClosure: ((UNNotificationRequest, @escaping (UNNotificationContent) -> Void) -> Bool)?

    /// Mocked function for `didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    @discardableResult
    public func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) -> Bool {
        self.mockCalled = true
        didReceiveNotificationRequestCallsCount += 1
        didReceiveNotificationRequestReceivedArguments = (request: request, contentHandler: contentHandler)
        didReceiveNotificationRequestReceivedInvocations.append((request: request, contentHandler: contentHandler))
        return didReceiveNotificationRequestClosure.map({ $0(request, contentHandler) }) ?? didReceiveNotificationRequestReturnValue
    }
    #endif 

    // MARK: - serviceExtensionTimeWillExpire

    #if canImport(UserNotifications)
    /// Number of times the function was called.  
    @Atomic public private(set) var serviceExtensionTimeWillExpireCallsCount = 0
    /// `true` if the function was ever called. 
    public var serviceExtensionTimeWillExpireCalled: Bool {
        return serviceExtensionTimeWillExpireCallsCount > 0
    }    
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    public var serviceExtensionTimeWillExpireClosure: (() -> Void)?

    /// Mocked function for `serviceExtensionTimeWillExpire()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func serviceExtensionTimeWillExpire() {
        self.mockCalled = true
        serviceExtensionTimeWillExpireCallsCount += 1
        serviceExtensionTimeWillExpireClosure?()
    }
    #endif 

    // MARK: - userNotificationCenter

    #if canImport(UserNotifications)
    /// Number of times the function was called.  
    @Atomic public private(set) var userNotificationCenter_withCompletionCallsCount = 0
    /// `true` if the function was ever called. 
    public var userNotificationCenter_withCompletionCalled: Bool {
        return userNotificationCenter_withCompletionCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic public private(set) var userNotificationCenter_withCompletionReceivedArguments: (center: UNUserNotificationCenter, response: UNNotificationResponse, completionHandler: () -> Void)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic public private(set) var userNotificationCenter_withCompletionReceivedInvocations: [(center: UNUserNotificationCenter, response: UNNotificationResponse, completionHandler: () -> Void)] = []
    /// Value to return from the mocked function. 
    public var userNotificationCenter_withCompletionReturnValue: Bool!
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`, 
     then the mock will attempt to return the value for `userNotificationCenter_withCompletionReturnValue`
     */
    public var userNotificationCenter_withCompletionClosure: ((UNUserNotificationCenter, UNNotificationResponse, @escaping () -> Void) -> Bool)?

    /// Mocked function for `userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) -> Bool {
        self.mockCalled = true
        userNotificationCenter_withCompletionCallsCount += 1
        userNotificationCenter_withCompletionReceivedArguments = (center: center, response: response, completionHandler: completionHandler)
        userNotificationCenter_withCompletionReceivedInvocations.append((center: center, response: response, completionHandler: completionHandler))
        return userNotificationCenter_withCompletionClosure.map({ $0(center, response, completionHandler) }) ?? userNotificationCenter_withCompletionReturnValue
    }
    #endif 

    // MARK: - userNotificationCenter

    #if canImport(UserNotifications)
    /// Number of times the function was called.  
    @Atomic public private(set) var userNotificationCenterCallsCount = 0
    /// `true` if the function was ever called. 
    public var userNotificationCenterCalled: Bool {
        return userNotificationCenterCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic public private(set) var userNotificationCenterReceivedArguments: (center: UNUserNotificationCenter, response: UNNotificationResponse)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic public private(set) var userNotificationCenterReceivedInvocations: [(center: UNUserNotificationCenter, response: UNNotificationResponse)] = []
    /// Value to return from the mocked function. 
    public var userNotificationCenterReturnValue: CustomerIOParsedPushPayload?
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`, 
     then the mock will attempt to return the value for `userNotificationCenterReturnValue`
     */
    public var userNotificationCenterClosure: ((UNUserNotificationCenter, UNNotificationResponse) -> CustomerIOParsedPushPayload?)?

    /// Mocked function for `userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse) -> CustomerIOParsedPushPayload? {
        self.mockCalled = true
        userNotificationCenterCallsCount += 1
        userNotificationCenterReceivedArguments = (center: center, response: response)
        userNotificationCenterReceivedInvocations.append((center: center, response: response))
        return userNotificationCenterClosure.map({ $0(center, response) }) ?? userNotificationCenterReturnValue
    }
    #endif 

    // MARK: - getConfiguration

    /// Number of times the function was called.  
    @Atomic public private(set) var getConfigurationCallsCount = 0
    /// `true` if the function was ever called. 
    public var getConfigurationCalled: Bool {
        return getConfigurationCallsCount > 0
    }    
    /// Value to return from the mocked function. 
    public var getConfigurationReturnValue: MessagingPushConfigOptions?
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`, 
     then the mock will attempt to return the value for `getConfigurationReturnValue`
     */
    public var getConfigurationClosure: (() -> MessagingPushConfigOptions?)?

    /// Mocked function for `getConfiguration()`. Your opportunity to return a mocked value and check result of mock in test code.
    @_spi(Internal)
    public func getConfiguration() -> MessagingPushConfigOptions? {
        self.mockCalled = true
        getConfigurationCallsCount += 1
        return getConfigurationClosure.map({ $0() }) ?? getConfigurationReturnValue
    }

}
/**
 Class to easily create a mocked version of the `PushClickHandler` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
@available(iOSApplicationExtension, unavailable)
internal class PushClickHandlerMock: PushClickHandler, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    internal var mockCalled: Bool = false // 

    internal init() {
        Mocks.shared.add(mock: self)
    }


    public func resetMock() {
        cleanupAfterPushInteractedWithCallsCount = 0
        cleanupAfterPushInteractedWithReceivedArguments = nil 
        cleanupAfterPushInteractedWithReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        trackPushMetricsCallsCount = 0
        trackPushMetricsReceivedArguments = nil 
        trackPushMetricsReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        handleDeepLinkCallsCount = 0
        handleDeepLinkReceivedArguments = nil 
        handleDeepLinkReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - cleanupAfterPushInteractedWith

    /// Number of times the function was called.  
    @Atomic internal private(set) var cleanupAfterPushInteractedWithCallsCount = 0
    /// `true` if the function was ever called. 
    internal var cleanupAfterPushInteractedWithCalled: Bool {
        return cleanupAfterPushInteractedWithCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var cleanupAfterPushInteractedWithReceivedArguments: (PushNotification)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var cleanupAfterPushInteractedWithReceivedInvocations: [(PushNotification)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var cleanupAfterPushInteractedWithClosure: ((PushNotification) -> Void)?

    /// Mocked function for `cleanupAfterPushInteractedWith(for push: PushNotification)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func cleanupAfterPushInteractedWith(for push: PushNotification) {
        self.mockCalled = true
        cleanupAfterPushInteractedWithCallsCount += 1
        cleanupAfterPushInteractedWithReceivedArguments = (push)
        cleanupAfterPushInteractedWithReceivedInvocations.append((push))
        cleanupAfterPushInteractedWithClosure?(push)
    }

    // MARK: - trackPushMetrics

    /// Number of times the function was called.  
    @Atomic internal private(set) var trackPushMetricsCallsCount = 0
    /// `true` if the function was ever called. 
    internal var trackPushMetricsCalled: Bool {
        return trackPushMetricsCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var trackPushMetricsReceivedArguments: (PushNotification)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var trackPushMetricsReceivedInvocations: [(PushNotification)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var trackPushMetricsClosure: ((PushNotification) -> Void)?

    /// Mocked function for `trackPushMetrics(for push: PushNotification)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func trackPushMetrics(for push: PushNotification) {
        self.mockCalled = true
        trackPushMetricsCallsCount += 1
        trackPushMetricsReceivedArguments = (push)
        trackPushMetricsReceivedInvocations.append((push))
        trackPushMetricsClosure?(push)
    }

    // MARK: - handleDeepLink

    /// Number of times the function was called.  
    @Atomic internal private(set) var handleDeepLinkCallsCount = 0
    /// `true` if the function was ever called. 
    internal var handleDeepLinkCalled: Bool {
        return handleDeepLinkCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var handleDeepLinkReceivedArguments: (PushNotification)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var handleDeepLinkReceivedInvocations: [(PushNotification)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var handleDeepLinkClosure: ((PushNotification) -> Void)?

    /// Mocked function for `handleDeepLink(for push: PushNotification)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func handleDeepLink(for push: PushNotification) {
        self.mockCalled = true
        handleDeepLinkCallsCount += 1
        handleDeepLinkReceivedArguments = (push)
        handleDeepLinkReceivedInvocations.append((push))
        handleDeepLinkClosure?(push)
    }

}
/**
 Class to easily create a mocked version of the `PushEventHandler` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
internal class PushEventHandlerMock: PushEventHandler, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    internal var mockCalled: Bool = false // 

    internal init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here. 
     When the getter of the property called, the value set here will be returned. Your chance to mock the property. 
     */
    internal var underlyingIdentifier: String!
    /// `true` if the getter or setter of property is called at least once. 
    internal var identifierCalled: Bool {
        identifierGetCalled || identifierSetCalled
    }
    /// `true` if the getter called on the property at least once. 
    internal var identifierGetCalled: Bool {
        identifierGetCallsCount > 0
    } 
    internal var identifierGetCallsCount = 0
    /// `true` if the setter called on the property at least once. 
    internal var identifierSetCalled: Bool {
        identifierSetCallsCount > 0
    } 
    internal var identifierSetCallsCount = 0
    /// The mocked property with a getter and setter. 
    internal var identifier: String {
        get { 
            self.mockCalled = true
            identifierGetCallsCount += 1
            return underlyingIdentifier 
        }
        set(value) { 
            self.mockCalled = true
            identifierSetCallsCount += 1
            underlyingIdentifier = value 
        }
    }    

    public func resetMock() {
        identifierGetCallsCount = 0
        identifierSetCallsCount = 0
        onPushActionCallsCount = 0
        onPushActionReceivedArguments = nil 
        onPushActionReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        shouldDisplayPushAppInForegroundCallsCount = 0
        shouldDisplayPushAppInForegroundReceivedArguments = nil 
        shouldDisplayPushAppInForegroundReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - onPushAction

    /// Number of times the function was called.  
    @Atomic internal private(set) var onPushActionCallsCount = 0
    /// `true` if the function was ever called. 
    internal var onPushActionCalled: Bool {
        return onPushActionCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var onPushActionReceivedArguments: (pushAction: PushNotificationAction, completionHandler: () -> Void)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var onPushActionReceivedInvocations: [(pushAction: PushNotificationAction, completionHandler: () -> Void)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var onPushActionClosure: ((PushNotificationAction, @escaping () -> Void) -> Void)?

    /// Mocked function for `onPushAction(_ pushAction: PushNotificationAction, completionHandler: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func onPushAction(_ pushAction: PushNotificationAction, completionHandler: @escaping () -> Void) {
        self.mockCalled = true
        onPushActionCallsCount += 1
        onPushActionReceivedArguments = (pushAction: pushAction, completionHandler: completionHandler)
        onPushActionReceivedInvocations.append((pushAction: pushAction, completionHandler: completionHandler))
        onPushActionClosure?(pushAction, completionHandler)
    }

    // MARK: - shouldDisplayPushAppInForeground

    /// Number of times the function was called.  
    @Atomic internal private(set) var shouldDisplayPushAppInForegroundCallsCount = 0
    /// `true` if the function was ever called. 
    internal var shouldDisplayPushAppInForegroundCalled: Bool {
        return shouldDisplayPushAppInForegroundCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var shouldDisplayPushAppInForegroundReceivedArguments: (push: PushNotification, completionHandler: (Bool) -> Void)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var shouldDisplayPushAppInForegroundReceivedInvocations: [(push: PushNotification, completionHandler: (Bool) -> Void)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var shouldDisplayPushAppInForegroundClosure: ((PushNotification, @escaping (Bool) -> Void) -> Void)?

    /// Mocked function for `shouldDisplayPushAppInForeground(_ push: PushNotification, completionHandler: @escaping (Bool) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func shouldDisplayPushAppInForeground(_ push: PushNotification, completionHandler: @escaping (Bool) -> Void) {
        self.mockCalled = true
        shouldDisplayPushAppInForegroundCallsCount += 1
        shouldDisplayPushAppInForegroundReceivedArguments = (push: push, completionHandler: completionHandler)
        shouldDisplayPushAppInForegroundReceivedInvocations.append((push: push, completionHandler: completionHandler))
        shouldDisplayPushAppInForegroundClosure?(push, completionHandler)
    }

}
/**
 Class to easily create a mocked version of the `PushEventHandlerProxy` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
@available(iOSApplicationExtension, unavailable)
internal class PushEventHandlerProxyMock: PushEventHandlerProxy, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    internal var mockCalled: Bool = false // 

    internal init() {
        Mocks.shared.add(mock: self)
    }


    public func resetMock() {
        addPushEventHandlerCallsCount = 0
        addPushEventHandlerReceivedArguments = nil 
        addPushEventHandlerReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        onPushActionCallsCount = 0
        onPushActionReceivedArguments = nil 
        onPushActionReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        shouldDisplayPushAppInForegroundCallsCount = 0
        shouldDisplayPushAppInForegroundReceivedArguments = nil 
        shouldDisplayPushAppInForegroundReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - addPushEventHandler

    /// Number of times the function was called.  
    @Atomic internal private(set) var addPushEventHandlerCallsCount = 0
    /// `true` if the function was ever called. 
    internal var addPushEventHandlerCalled: Bool {
        return addPushEventHandlerCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var addPushEventHandlerReceivedArguments: (PushEventHandler)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var addPushEventHandlerReceivedInvocations: [(PushEventHandler)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var addPushEventHandlerClosure: ((PushEventHandler) -> Void)?

    /// Mocked function for `addPushEventHandler(_ newHandler: PushEventHandler)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func addPushEventHandler(_ newHandler: PushEventHandler) {
        self.mockCalled = true
        addPushEventHandlerCallsCount += 1
        addPushEventHandlerReceivedArguments = (newHandler)
        addPushEventHandlerReceivedInvocations.append((newHandler))
        addPushEventHandlerClosure?(newHandler)
    }

    // MARK: - onPushAction

    /// Number of times the function was called.  
    @Atomic internal private(set) var onPushActionCallsCount = 0
    /// `true` if the function was ever called. 
    internal var onPushActionCalled: Bool {
        return onPushActionCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var onPushActionReceivedArguments: (pushAction: PushNotificationAction, completionHandler: () -> Void)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var onPushActionReceivedInvocations: [(pushAction: PushNotificationAction, completionHandler: () -> Void)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var onPushActionClosure: ((PushNotificationAction, @escaping () -> Void) -> Void)?

    /// Mocked function for `onPushAction(_ pushAction: PushNotificationAction, completionHandler: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func onPushAction(_ pushAction: PushNotificationAction, completionHandler: @escaping () -> Void) {
        self.mockCalled = true
        onPushActionCallsCount += 1
        onPushActionReceivedArguments = (pushAction: pushAction, completionHandler: completionHandler)
        onPushActionReceivedInvocations.append((pushAction: pushAction, completionHandler: completionHandler))
        onPushActionClosure?(pushAction, completionHandler)
    }

    // MARK: - shouldDisplayPushAppInForeground

    /// Number of times the function was called.  
    @Atomic internal private(set) var shouldDisplayPushAppInForegroundCallsCount = 0
    /// `true` if the function was ever called. 
    internal var shouldDisplayPushAppInForegroundCalled: Bool {
        return shouldDisplayPushAppInForegroundCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var shouldDisplayPushAppInForegroundReceivedArguments: (push: PushNotification, completionHandler: (Bool) -> Void)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var shouldDisplayPushAppInForegroundReceivedInvocations: [(push: PushNotification, completionHandler: (Bool) -> Void)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var shouldDisplayPushAppInForegroundClosure: ((PushNotification, @escaping (Bool) -> Void) -> Void)?

    /// Mocked function for `shouldDisplayPushAppInForeground(_ push: PushNotification, completionHandler: @escaping (Bool) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func shouldDisplayPushAppInForeground(_ push: PushNotification, completionHandler: @escaping (Bool) -> Void) {
        self.mockCalled = true
        shouldDisplayPushAppInForegroundCallsCount += 1
        shouldDisplayPushAppInForegroundReceivedArguments = (push: push, completionHandler: completionHandler)
        shouldDisplayPushAppInForegroundReceivedInvocations.append((push: push, completionHandler: completionHandler))
        shouldDisplayPushAppInForegroundClosure?(push, completionHandler)
    }

}
/**
 Class to easily create a mocked version of the `PushHistory` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
internal class PushHistoryMock: PushHistory, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    internal var mockCalled: Bool = false // 

    internal init() {
        Mocks.shared.add(mock: self)
    }


    public func resetMock() {
        hasHandledPushCallsCount = 0
        hasHandledPushReceivedArguments = nil 
        hasHandledPushReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - hasHandledPush

    /// Number of times the function was called.  
    @Atomic internal private(set) var hasHandledPushCallsCount = 0
    /// `true` if the function was ever called. 
    internal var hasHandledPushCalled: Bool {
        return hasHandledPushCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var hasHandledPushReceivedArguments: (pushEvent: PushHistoryEvent, pushId: String, pushDeliveryDate: Date)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var hasHandledPushReceivedInvocations: [(pushEvent: PushHistoryEvent, pushId: String, pushDeliveryDate: Date)] = []
    /// Value to return from the mocked function. 
    internal var hasHandledPushReturnValue: Bool!
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`, 
     then the mock will attempt to return the value for `hasHandledPushReturnValue`
     */
    internal var hasHandledPushClosure: ((PushHistoryEvent, String, Date) -> Bool)?

    /// Mocked function for `hasHandledPush(pushEvent: PushHistoryEvent, pushId: String, pushDeliveryDate: Date)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func hasHandledPush(pushEvent: PushHistoryEvent, pushId: String, pushDeliveryDate: Date) -> Bool {
        self.mockCalled = true
        hasHandledPushCallsCount += 1
        hasHandledPushReceivedArguments = (pushEvent: pushEvent, pushId: pushId, pushDeliveryDate: pushDeliveryDate)
        hasHandledPushReceivedInvocations.append((pushEvent: pushEvent, pushId: pushId, pushDeliveryDate: pushDeliveryDate))
        return hasHandledPushClosure.map({ $0(pushEvent, pushId, pushDeliveryDate) }) ?? hasHandledPushReturnValue
    }

}
/**
 Class to easily create a mocked version of the `UserNotificationCenter` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
internal class UserNotificationCenterMock: UserNotificationCenter, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    internal var mockCalled: Bool = false // 

    internal init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here. 
     When the getter of the property called, the value set here will be returned. Your chance to mock the property. 
     */
    internal var underlyingCurrentDelegate: UNUserNotificationCenterDelegate? = nil
    /// `true` if the getter or setter of property is called at least once. 
    internal var currentDelegateCalled: Bool {
        currentDelegateGetCalled || currentDelegateSetCalled
    }
    /// `true` if the getter called on the property at least once. 
    internal var currentDelegateGetCalled: Bool {
        currentDelegateGetCallsCount > 0
    } 
    internal var currentDelegateGetCallsCount = 0
    /// `true` if the setter called on the property at least once. 
    internal var currentDelegateSetCalled: Bool {
        currentDelegateSetCallsCount > 0
    } 
    internal var currentDelegateSetCallsCount = 0
    /// The mocked property with a getter and setter. 
    internal var currentDelegate: UNUserNotificationCenterDelegate? {
        get { 
            self.mockCalled = true
            currentDelegateGetCallsCount += 1
            return underlyingCurrentDelegate 
        }
        set(value) { 
            self.mockCalled = true
            currentDelegateSetCallsCount += 1
            underlyingCurrentDelegate = value 
        }
    }    

    public func resetMock() {
        currentDelegate = nil 
        currentDelegateGetCallsCount = 0
        currentDelegateSetCallsCount = 0
    }

}
/**
 Class to easily create a mocked version of the `UserNotificationCenterIntegration` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
public class UserNotificationCenterIntegrationMock: UserNotificationCenterIntegration, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    public var mockCalled: Bool = false // 

    public init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here. 
     When the getter of the property called, the value set here will be returned. Your chance to mock the property. 
     */
    public var underlyingDelegate: UNUserNotificationCenterDelegate? = nil
    /// `true` if the getter or setter of property is called at least once. 
    public var delegateCalled: Bool {
        delegateGetCalled || delegateSetCalled
    }
    /// `true` if the getter called on the property at least once. 
    public var delegateGetCalled: Bool {
        delegateGetCallsCount > 0
    } 
    public var delegateGetCallsCount = 0
    /// `true` if the setter called on the property at least once. 
    public var delegateSetCalled: Bool {
        delegateSetCallsCount > 0
    } 
    public var delegateSetCallsCount = 0
    /// The mocked property with a getter and setter. 
    public var delegate: UNUserNotificationCenterDelegate? {
        get { 
            self.mockCalled = true
            delegateGetCallsCount += 1
            return underlyingDelegate 
        }
        set(value) { 
            self.mockCalled = true
            delegateSetCallsCount += 1
            underlyingDelegate = value 
        }
    }    

    public func resetMock() {
        delegate = nil 
        delegateGetCallsCount = 0
        delegateSetCallsCount = 0
    }

}

// swiftlint:enable all
