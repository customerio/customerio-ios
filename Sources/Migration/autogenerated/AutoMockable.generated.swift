// Generated using Sourcery 2.0.3 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT
// swiftlint:disable all

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif
#if canImport(UserNotifications)
import UserNotifications
#endif
import CioInternalCommon

/**
 ######################################################
 Documentation
 ######################################################

 This automatically generated file you are viewing contains mock classes that you can use in your test suite.

 * How do you generate a new mock class?

 1. Mocks are generated from Swift protocols. So, you must make one.

 ```
 protocol FriendsRepository {
     func acceptFriendRequest<Attributes: Encodable>(attributes: Attributes, _ onComplete: @escaping () -> Void)
 }

 class AppFriendsRepository: FriendsRepository {
     ...
 }
 ```

 2. Have your new protocol extend `AutoMockable`:

 ```
 protocol FriendsRepository: AutoMockable {
     func acceptFriendRequest<Attributes: Encodable>(
         // sourcery:Type=Encodable
         attributes: Attributes,
         _ onComplete: @escaping () -> Void)
 }
 ```

 > Notice the use of `// sourcery:Type=Encodable` for the generic type parameter. Without this, the mock would
 fail to compile: `functionNameReceiveArguments = (Attributes)` because `Attributes` is unknown to this `var`.
 Instead, we give the parameter a different type to use for the mock. `Encodable` works in this case.
 It will require a cast in the test function code, however.

 3. Run the command `make generate` on your machine. The new mock should be added to this file.

 * How do you use the mocks in your test class?

 ```
 class ExampleViewModelTest: XCTestCase {
     var viewModel: ExampleViewModel!
     var exampleRepositoryMock: ExampleRepositoryMock!
     override func setUp() {
         exampleRepositoryMock = ExampleRepositoryMock()
         viewModel = AppExampleViewModel(exampleRepository: exampleRepositoryMock)
     }
 }
 ```

 Or, you may need to inject the mock in a different way using the DI.shared graph:

 ```
 class ExampleTest: XCTestCase {
     var exampleViewModelMock: ExampleViewModelMock!
     var example: Example!
     override func setUp() {
         exampleViewModelMock = ExampleViewModelMock()
         DI.shared.override(.exampleViewModel, value: exampleViewModelMock, forType: ExampleViewModel.self)
         example = Example()
     }
 }

 ```

 */

/**
 Class to easily create a mocked version of the `DataPipelineMigrationAction` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class DataPipelineMigrationActionMock: DataPipelineMigrationAction, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        processAlreadyIdentifiedUserCallsCount = 0
        processAlreadyIdentifiedUserReceivedArguments = nil
        processAlreadyIdentifiedUserReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        processIdentifyFromBGQCallsCount = 0
        processIdentifyFromBGQReceivedArguments = nil
        processIdentifyFromBGQReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        processScreenEventFromBGQCallsCount = 0
        processScreenEventFromBGQReceivedArguments = nil
        processScreenEventFromBGQReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        processEventFromBGQCallsCount = 0
        processEventFromBGQReceivedArguments = nil
        processEventFromBGQReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        processDeleteTokenFromBGQCallsCount = 0
        processDeleteTokenFromBGQReceivedArguments = nil
        processDeleteTokenFromBGQReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        processRegisterDeviceFromBGQCallsCount = 0
        processRegisterDeviceFromBGQReceivedArguments = nil
        processRegisterDeviceFromBGQReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        processMetricsFromBGQCallsCount = 0
        processMetricsFromBGQReceivedArguments = nil
        processMetricsFromBGQReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - processAlreadyIdentifiedUser

    /// Number of times the function was called.
    @Atomic public private(set) var processAlreadyIdentifiedUserCallsCount = 0
    /// `true` if the function was ever called.
    public var processAlreadyIdentifiedUserCalled: Bool {
        processAlreadyIdentifiedUserCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var processAlreadyIdentifiedUserReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var processAlreadyIdentifiedUserReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var processAlreadyIdentifiedUserClosure: ((String) -> Void)?

    /// Mocked function for `processAlreadyIdentifiedUser(identifier: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func processAlreadyIdentifiedUser(identifier: String) {
        mockCalled = true
        processAlreadyIdentifiedUserCallsCount += 1
        processAlreadyIdentifiedUserReceivedArguments = identifier
        processAlreadyIdentifiedUserReceivedInvocations.append(identifier)
        processAlreadyIdentifiedUserClosure?(identifier)
    }

    // MARK: - processIdentifyFromBGQ

    /// Number of times the function was called.
    @Atomic public private(set) var processIdentifyFromBGQCallsCount = 0
    /// `true` if the function was ever called.
    public var processIdentifyFromBGQCalled: Bool {
        processIdentifyFromBGQCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var processIdentifyFromBGQReceivedArguments: (identifier: String, timestamp: String, body: [String: Any]?)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var processIdentifyFromBGQReceivedInvocations: [(identifier: String, timestamp: String, body: [String: Any]?)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var processIdentifyFromBGQClosure: ((String, String, [String: Any]?) -> Void)?

    /// Mocked function for `processIdentifyFromBGQ(identifier: String, timestamp: String, body: [String: Any]?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func processIdentifyFromBGQ(identifier: String, timestamp: String, body: [String: Any]?) {
        mockCalled = true
        processIdentifyFromBGQCallsCount += 1
        processIdentifyFromBGQReceivedArguments = (identifier: identifier, timestamp: timestamp, body: body)
        processIdentifyFromBGQReceivedInvocations.append((identifier: identifier, timestamp: timestamp, body: body))
        processIdentifyFromBGQClosure?(identifier, timestamp, body)
    }

    // MARK: - processScreenEventFromBGQ

    /// Number of times the function was called.
    @Atomic public private(set) var processScreenEventFromBGQCallsCount = 0
    /// `true` if the function was ever called.
    public var processScreenEventFromBGQCalled: Bool {
        processScreenEventFromBGQCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var processScreenEventFromBGQReceivedArguments: (identifier: String, name: String, timestamp: String?, properties: [String: Any])?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var processScreenEventFromBGQReceivedInvocations: [(identifier: String, name: String, timestamp: String?, properties: [String: Any])] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var processScreenEventFromBGQClosure: ((String, String, String?, [String: Any]) -> Void)?

    /// Mocked function for `processScreenEventFromBGQ(identifier: String, name: String, timestamp: String?, properties: [String: Any])`. Your opportunity to return a mocked value and check result of mock in test code.
    public func processScreenEventFromBGQ(identifier: String, name: String, timestamp: String?, properties: [String: Any]) {
        mockCalled = true
        processScreenEventFromBGQCallsCount += 1
        processScreenEventFromBGQReceivedArguments = (identifier: identifier, name: name, timestamp: timestamp, properties: properties)
        processScreenEventFromBGQReceivedInvocations.append((identifier: identifier, name: name, timestamp: timestamp, properties: properties))
        processScreenEventFromBGQClosure?(identifier, name, timestamp, properties)
    }

    // MARK: - processEventFromBGQ

    /// Number of times the function was called.
    @Atomic public private(set) var processEventFromBGQCallsCount = 0
    /// `true` if the function was ever called.
    public var processEventFromBGQCalled: Bool {
        processEventFromBGQCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var processEventFromBGQReceivedArguments: (identifier: String, name: String, timestamp: String?, properties: [String: Any])?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var processEventFromBGQReceivedInvocations: [(identifier: String, name: String, timestamp: String?, properties: [String: Any])] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var processEventFromBGQClosure: ((String, String, String?, [String: Any]) -> Void)?

    /// Mocked function for `processEventFromBGQ(identifier: String, name: String, timestamp: String?, properties: [String: Any])`. Your opportunity to return a mocked value and check result of mock in test code.
    public func processEventFromBGQ(identifier: String, name: String, timestamp: String?, properties: [String: Any]) {
        mockCalled = true
        processEventFromBGQCallsCount += 1
        processEventFromBGQReceivedArguments = (identifier: identifier, name: name, timestamp: timestamp, properties: properties)
        processEventFromBGQReceivedInvocations.append((identifier: identifier, name: name, timestamp: timestamp, properties: properties))
        processEventFromBGQClosure?(identifier, name, timestamp, properties)
    }

    // MARK: - processDeleteTokenFromBGQ

    /// Number of times the function was called.
    @Atomic public private(set) var processDeleteTokenFromBGQCallsCount = 0
    /// `true` if the function was ever called.
    public var processDeleteTokenFromBGQCalled: Bool {
        processDeleteTokenFromBGQCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var processDeleteTokenFromBGQReceivedArguments: (identifier: String, token: String, timestamp: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var processDeleteTokenFromBGQReceivedInvocations: [(identifier: String, token: String, timestamp: String)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var processDeleteTokenFromBGQClosure: ((String, String, String) -> Void)?

    /// Mocked function for `processDeleteTokenFromBGQ(identifier: String, token: String, timestamp: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func processDeleteTokenFromBGQ(identifier: String, token: String, timestamp: String) {
        mockCalled = true
        processDeleteTokenFromBGQCallsCount += 1
        processDeleteTokenFromBGQReceivedArguments = (identifier: identifier, token: token, timestamp: timestamp)
        processDeleteTokenFromBGQReceivedInvocations.append((identifier: identifier, token: token, timestamp: timestamp))
        processDeleteTokenFromBGQClosure?(identifier, token, timestamp)
    }

    // MARK: - processRegisterDeviceFromBGQ

    /// Number of times the function was called.
    @Atomic public private(set) var processRegisterDeviceFromBGQCallsCount = 0
    /// `true` if the function was ever called.
    public var processRegisterDeviceFromBGQCalled: Bool {
        processRegisterDeviceFromBGQCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var processRegisterDeviceFromBGQReceivedArguments: (identifier: String, token: String, timestamp: String, attributes: [String: Any]?)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var processRegisterDeviceFromBGQReceivedInvocations: [(identifier: String, token: String, timestamp: String, attributes: [String: Any]?)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var processRegisterDeviceFromBGQClosure: ((String, String, String, [String: Any]?) -> Void)?

    /// Mocked function for `processRegisterDeviceFromBGQ(identifier: String, token: String, timestamp: String, attributes: [String: Any]?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func processRegisterDeviceFromBGQ(identifier: String, token: String, timestamp: String, attributes: [String: Any]?) {
        mockCalled = true
        processRegisterDeviceFromBGQCallsCount += 1
        processRegisterDeviceFromBGQReceivedArguments = (identifier: identifier, token: token, timestamp: timestamp, attributes: attributes)
        processRegisterDeviceFromBGQReceivedInvocations.append((identifier: identifier, token: token, timestamp: timestamp, attributes: attributes))
        processRegisterDeviceFromBGQClosure?(identifier, token, timestamp, attributes)
    }

    // MARK: - processMetricsFromBGQ

    /// Number of times the function was called.
    @Atomic public private(set) var processMetricsFromBGQCallsCount = 0
    /// `true` if the function was ever called.
    public var processMetricsFromBGQCalled: Bool {
        processMetricsFromBGQCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var processMetricsFromBGQReceivedArguments: (token: String?, event: String, deliveryId: String, timestamp: String, metaData: [String: Any])?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var processMetricsFromBGQReceivedInvocations: [(token: String?, event: String, deliveryId: String, timestamp: String, metaData: [String: Any])] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var processMetricsFromBGQClosure: ((String?, String, String, String, [String: Any]) -> Void)?

    /// Mocked function for `processMetricsFromBGQ(token: String?, event: String, deliveryId: String, timestamp: String, metaData: [String: Any])`. Your opportunity to return a mocked value and check result of mock in test code.
    public func processMetricsFromBGQ(token: String?, event: String, deliveryId: String, timestamp: String, metaData: [String: Any]) {
        mockCalled = true
        processMetricsFromBGQCallsCount += 1
        processMetricsFromBGQReceivedArguments = (token: token, event: event, deliveryId: deliveryId, timestamp: timestamp, metaData: metaData)
        processMetricsFromBGQReceivedInvocations.append((token: token, event: event, deliveryId: deliveryId, timestamp: timestamp, metaData: metaData))
        processMetricsFromBGQClosure?(token, event, deliveryId, timestamp, metaData)
    }
}

// swiftlint:enable all
