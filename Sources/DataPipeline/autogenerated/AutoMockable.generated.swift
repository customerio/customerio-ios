// Generated using Sourcery 2.0.3 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT
// swiftlint:disable all

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif
#if canImport(UserNotifications)
import UserNotifications
#endif
import CioInternalCommon

/**
######################################################
Documentation
######################################################

This automatically generated file you are viewing contains mock classes that you can use in your test suite. 

* How do you generate a new mock class? 

1. Mocks are generated from Swift protocols. So, you must make one. 

```
protocol FriendsRepository {
    func acceptFriendRequest<Attributes: Encodable>(attributes: Attributes, _ onComplete: @escaping () -> Void)
}

class AppFriendsRepository: FriendsRepository {
    ...
}
```

2. Have your new protocol extend `AutoMockable`:

```
protocol FriendsRepository: AutoMockable {
    func acceptFriendRequest<Attributes: Encodable>(
        // sourcery:Type=Encodable
        attributes: Attributes, 
        _ onComplete: @escaping () -> Void)
}
```

> Notice the use of `// sourcery:Type=Encodable` for the generic type parameter. Without this, the mock would 
fail to compile: `functionNameReceiveArguments = (Attributes)` because `Attributes` is unknown to this `var`. 
Instead, we give the parameter a different type to use for the mock. `Encodable` works in this case. 
It will require a cast in the test function code, however. 

3. Run the command `make generate` on your machine. The new mock should be added to this file. 

* How do you use the mocks in your test class? 

```
class ExampleViewModelTest: XCTestCase {
    var viewModel: ExampleViewModel!
    var exampleRepositoryMock: ExampleRepositoryMock!
    override func setUp() {
        exampleRepositoryMock = ExampleRepositoryMock()
        viewModel = AppExampleViewModel(exampleRepository: exampleRepositoryMock)
    }
}
```

Or, you may need to inject the mock in a different way using the DI.shared graph:

```
class ExampleTest: XCTestCase {
    var exampleViewModelMock: ExampleViewModelMock!
    var example: Example!
    override func setUp() {
        exampleViewModelMock = ExampleViewModelMock()
        DI.shared.override(.exampleViewModel, value: exampleViewModelMock, forType: ExampleViewModel.self)
        example = Example()
    }
}

```

*/















/**
 Class to easily create a mocked version of the `DataPipelinesLogger` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
internal class DataPipelinesLoggerMock: DataPipelinesLogger, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    internal var mockCalled: Bool = false // 

    internal init() {
        Mocks.shared.add(mock: self)
    }


    public func resetMock() {
        logStoringDevicePushTokenCallsCount = 0
        logStoringDevicePushTokenReceivedArguments = nil 
        logStoringDevicePushTokenReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        logStoringBlankPushTokenCallsCount = 0

        self.mockCalled = false // do last as resetting properties above can make this true
        logRegisteringPushTokenCallsCount = 0
        logRegisteringPushTokenReceivedArguments = nil 
        logRegisteringPushTokenReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        logPushTokenRefreshedCallsCount = 0

        self.mockCalled = false // do last as resetting properties above can make this true
        automaticTokenRegistrationForNewProfileCallsCount = 0
        automaticTokenRegistrationForNewProfileReceivedArguments = nil 
        automaticTokenRegistrationForNewProfileReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
        logDeletingTokenDueToNewProfileIdentificationCallsCount = 0

        self.mockCalled = false // do last as resetting properties above can make this true
        logTrackingDevicesAttributesWithoutValidTokenCallsCount = 0

        self.mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - logStoringDevicePushToken

    /// Number of times the function was called.  
    @Atomic internal private(set) var logStoringDevicePushTokenCallsCount = 0
    /// `true` if the function was ever called. 
    internal var logStoringDevicePushTokenCalled: Bool {
        return logStoringDevicePushTokenCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var logStoringDevicePushTokenReceivedArguments: (token: String, userId: String?)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var logStoringDevicePushTokenReceivedInvocations: [(token: String, userId: String?)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var logStoringDevicePushTokenClosure: ((String, String?) -> Void)?

    /// Mocked function for `logStoringDevicePushToken(token: String, userId: String?)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func logStoringDevicePushToken(token: String, userId: String?) {
        self.mockCalled = true
        logStoringDevicePushTokenCallsCount += 1
        logStoringDevicePushTokenReceivedArguments = (token: token, userId: userId)
        logStoringDevicePushTokenReceivedInvocations.append((token: token, userId: userId))
        logStoringDevicePushTokenClosure?(token, userId)
    }

    // MARK: - logStoringBlankPushToken

    /// Number of times the function was called.  
    @Atomic internal private(set) var logStoringBlankPushTokenCallsCount = 0
    /// `true` if the function was ever called. 
    internal var logStoringBlankPushTokenCalled: Bool {
        return logStoringBlankPushTokenCallsCount > 0
    }    
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var logStoringBlankPushTokenClosure: (() -> Void)?

    /// Mocked function for `logStoringBlankPushToken()`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func logStoringBlankPushToken() {
        self.mockCalled = true
        logStoringBlankPushTokenCallsCount += 1
        logStoringBlankPushTokenClosure?()
    }

    // MARK: - logRegisteringPushToken

    /// Number of times the function was called.  
    @Atomic internal private(set) var logRegisteringPushTokenCallsCount = 0
    /// `true` if the function was ever called. 
    internal var logRegisteringPushTokenCalled: Bool {
        return logRegisteringPushTokenCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var logRegisteringPushTokenReceivedArguments: (token: String, userId: String?)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var logRegisteringPushTokenReceivedInvocations: [(token: String, userId: String?)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var logRegisteringPushTokenClosure: ((String, String?) -> Void)?

    /// Mocked function for `logRegisteringPushToken(token: String, userId: String?)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func logRegisteringPushToken(token: String, userId: String?) {
        self.mockCalled = true
        logRegisteringPushTokenCallsCount += 1
        logRegisteringPushTokenReceivedArguments = (token: token, userId: userId)
        logRegisteringPushTokenReceivedInvocations.append((token: token, userId: userId))
        logRegisteringPushTokenClosure?(token, userId)
    }

    // MARK: - logPushTokenRefreshed

    /// Number of times the function was called.  
    @Atomic internal private(set) var logPushTokenRefreshedCallsCount = 0
    /// `true` if the function was ever called. 
    internal var logPushTokenRefreshedCalled: Bool {
        return logPushTokenRefreshedCallsCount > 0
    }    
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var logPushTokenRefreshedClosure: (() -> Void)?

    /// Mocked function for `logPushTokenRefreshed()`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func logPushTokenRefreshed() {
        self.mockCalled = true
        logPushTokenRefreshedCallsCount += 1
        logPushTokenRefreshedClosure?()
    }

    // MARK: - automaticTokenRegistrationForNewProfile

    /// Number of times the function was called.  
    @Atomic internal private(set) var automaticTokenRegistrationForNewProfileCallsCount = 0
    /// `true` if the function was ever called. 
    internal var automaticTokenRegistrationForNewProfileCalled: Bool {
        return automaticTokenRegistrationForNewProfileCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var automaticTokenRegistrationForNewProfileReceivedArguments: (token: String, userId: String)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var automaticTokenRegistrationForNewProfileReceivedInvocations: [(token: String, userId: String)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var automaticTokenRegistrationForNewProfileClosure: ((String, String) -> Void)?

    /// Mocked function for `automaticTokenRegistrationForNewProfile(token: String, userId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func automaticTokenRegistrationForNewProfile(token: String, userId: String) {
        self.mockCalled = true
        automaticTokenRegistrationForNewProfileCallsCount += 1
        automaticTokenRegistrationForNewProfileReceivedArguments = (token: token, userId: userId)
        automaticTokenRegistrationForNewProfileReceivedInvocations.append((token: token, userId: userId))
        automaticTokenRegistrationForNewProfileClosure?(token, userId)
    }

    // MARK: - logDeletingTokenDueToNewProfileIdentification

    /// Number of times the function was called.  
    @Atomic internal private(set) var logDeletingTokenDueToNewProfileIdentificationCallsCount = 0
    /// `true` if the function was ever called. 
    internal var logDeletingTokenDueToNewProfileIdentificationCalled: Bool {
        return logDeletingTokenDueToNewProfileIdentificationCallsCount > 0
    }    
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var logDeletingTokenDueToNewProfileIdentificationClosure: (() -> Void)?

    /// Mocked function for `logDeletingTokenDueToNewProfileIdentification()`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func logDeletingTokenDueToNewProfileIdentification() {
        self.mockCalled = true
        logDeletingTokenDueToNewProfileIdentificationCallsCount += 1
        logDeletingTokenDueToNewProfileIdentificationClosure?()
    }

    // MARK: - logTrackingDevicesAttributesWithoutValidToken

    /// Number of times the function was called.  
    @Atomic internal private(set) var logTrackingDevicesAttributesWithoutValidTokenCallsCount = 0
    /// `true` if the function was ever called. 
    internal var logTrackingDevicesAttributesWithoutValidTokenCalled: Bool {
        return logTrackingDevicesAttributesWithoutValidTokenCallsCount > 0
    }    
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var logTrackingDevicesAttributesWithoutValidTokenClosure: (() -> Void)?

    /// Mocked function for `logTrackingDevicesAttributesWithoutValidToken()`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func logTrackingDevicesAttributesWithoutValidToken() {
        self.mockCalled = true
        logTrackingDevicesAttributesWithoutValidTokenCallsCount += 1
        logTrackingDevicesAttributesWithoutValidTokenClosure?()
    }

}
/**
 Class to easily create a mocked version of the `DeviceAttributesProvider` class. 
 This class is equipped with functions and properties ready for you to mock! 

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK. 
 */
internal class DeviceAttributesProviderMock: DeviceAttributesProvider, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called. 
    internal var mockCalled: Bool = false // 

    internal init() {
        Mocks.shared.add(mock: self)
    }


    public func resetMock() {
        getDefaultDeviceAttributesCallsCount = 0
        getDefaultDeviceAttributesReceivedArguments = nil 
        getDefaultDeviceAttributesReceivedInvocations = []

        self.mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - getDefaultDeviceAttributes

    /// Number of times the function was called.  
    @Atomic internal private(set) var getDefaultDeviceAttributesCallsCount = 0
    /// `true` if the function was ever called. 
    internal var getDefaultDeviceAttributesCalled: Bool {
        return getDefaultDeviceAttributesCallsCount > 0
    }    
    /// The arguments from the *last* time the function was called. 
    @Atomic internal private(set) var getDefaultDeviceAttributesReceivedArguments: (([String: Any]) -> Void)?
    /// Arguments from *all* of the times that the function was called. 
    @Atomic internal private(set) var getDefaultDeviceAttributesReceivedInvocations: [(([String: Any]) -> Void)] = []
    /** 
     Set closure to get called when function gets called. Great way to test logic or return a value for the function. 
     */
    internal var getDefaultDeviceAttributesClosure: ((@escaping ([String: Any]) -> Void) -> Void)?

    /// Mocked function for `getDefaultDeviceAttributes(onComplete: @escaping ([String: Any]) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func getDefaultDeviceAttributes(onComplete: @escaping ([String: Any]) -> Void) {
        self.mockCalled = true
        getDefaultDeviceAttributesCallsCount += 1
        getDefaultDeviceAttributesReceivedArguments = (onComplete)
        getDefaultDeviceAttributesReceivedInvocations.append((onComplete))
        getDefaultDeviceAttributesClosure?(onComplete)
    }

}

// swiftlint:enable all
