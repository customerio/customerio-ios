// Generated using Sourcery 2.0.3 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT
// swiftlint:disable all

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif
#if canImport(UserNotifications)
import UserNotifications
#endif
import CioInternalCommon
import UIKit

/**
 ######################################################
 Documentation
 ######################################################

 This automatically generated file you are viewing contains mock classes that you can use in your test suite.

 * How do you generate a new mock class?

 1. Mocks are generated from Swift protocols. So, you must make one.

 ```
 protocol FriendsRepository {
     func acceptFriendRequest<Attributes: Encodable>(attributes: Attributes, _ onComplete: @escaping () -> Void)
 }

 class AppFriendsRepository: FriendsRepository {
     ...
 }
 ```

 2. Have your new protocol extend `AutoMockable`:

 ```
 protocol FriendsRepository: AutoMockable {
     func acceptFriendRequest<Attributes: Encodable>(
         // sourcery:Type=Encodable
         attributes: Attributes,
         _ onComplete: @escaping () -> Void)
 }
 ```

 > Notice the use of `// sourcery:Type=Encodable` for the generic type parameter. Without this, the mock would
 fail to compile: `functionNameReceiveArguments = (Attributes)` because `Attributes` is unknown to this `var`.
 Instead, we give the parameter a different type to use for the mock. `Encodable` works in this case.
 It will require a cast in the test function code, however.

 3. Run the command `make generate` on your machine. The new mock should be added to this file.

 * How do you use the mocks in your test class?

 ```
 class ExampleViewModelTest: XCTestCase {
     var viewModel: ExampleViewModel!
     var exampleRepositoryMock: ExampleRepositoryMock!
     override func setUp() {
         exampleRepositoryMock = ExampleRepositoryMock()
         viewModel = AppExampleViewModel(exampleRepository: exampleRepositoryMock)
     }
 }
 ```

 Or, you may need to inject the mock in a different way using the DI.shared graph:

 ```
 class ExampleTest: XCTestCase {
     var exampleViewModelMock: ExampleViewModelMock!
     var example: Example!
     override func setUp() {
         exampleViewModelMock = ExampleViewModelMock()
         DI.shared.override(.exampleViewModel, value: exampleViewModelMock, forType: ExampleViewModel.self)
         example = Example()
     }
 }

 ```

 */

/**
 Class to easily create a mocked version of the `EngineWebInstance` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
class EngineWebInstanceMock: EngineWebInstance, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    var mockCalled: Bool = false //

    init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    var underlyingDelegate: EngineWebDelegate? = nil
    /// `true` if the getter or setter of property is called at least once.
    var delegateCalled: Bool {
        delegateGetCalled || delegateSetCalled
    }

    /// `true` if the getter called on the property at least once.
    var delegateGetCalled: Bool {
        delegateGetCallsCount > 0
    }

    var delegateGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    var delegateSetCalled: Bool {
        delegateSetCallsCount > 0
    }

    var delegateSetCallsCount = 0
    /// The mocked property with a getter and setter.
    var delegate: EngineWebDelegate? {
        get {
            mockCalled = true
            delegateGetCallsCount += 1
            return underlyingDelegate
        }
        set(value) {
            mockCalled = true
            delegateSetCallsCount += 1
            underlyingDelegate = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    var underlyingView: UIView!
    /// `true` if the getter or setter of property is called at least once.
    var viewCalled: Bool {
        viewGetCalled || viewSetCalled
    }

    /// `true` if the getter called on the property at least once.
    var viewGetCalled: Bool {
        viewGetCallsCount > 0
    }

    var viewGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    var viewSetCalled: Bool {
        viewSetCallsCount > 0
    }

    var viewSetCallsCount = 0
    /// The mocked property with a getter and setter.
    var view: UIView {
        get {
            mockCalled = true
            viewGetCallsCount += 1
            return underlyingView
        }
        set(value) {
            mockCalled = true
            viewSetCallsCount += 1
            underlyingView = value
        }
    }

    public func resetMock() {
        delegate = nil
        delegateGetCallsCount = 0
        delegateSetCallsCount = 0
        viewGetCallsCount = 0
        viewSetCallsCount = 0
        cleanEngineWebCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - cleanEngineWeb

    /// Number of times the function was called.
    @Atomic private(set) var cleanEngineWebCallsCount = 0
    /// `true` if the function was ever called.
    var cleanEngineWebCalled: Bool {
        cleanEngineWebCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var cleanEngineWebClosure: (() -> Void)?

    /// Mocked function for `cleanEngineWeb()`. Your opportunity to return a mocked value and check result of mock in test code.
    func cleanEngineWeb() {
        mockCalled = true
        cleanEngineWebCallsCount += 1
        cleanEngineWebClosure?()
    }
}

/**
 Class to easily create a mocked version of the `GistInstance` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
class GistInstanceMock: GistInstance, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    var mockCalled: Bool = false //

    init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    var underlyingSiteId: String!
    /// `true` if the getter or setter of property is called at least once.
    var siteIdCalled: Bool {
        siteIdGetCalled || siteIdSetCalled
    }

    /// `true` if the getter called on the property at least once.
    var siteIdGetCalled: Bool {
        siteIdGetCallsCount > 0
    }

    var siteIdGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    var siteIdSetCalled: Bool {
        siteIdSetCallsCount > 0
    }

    var siteIdSetCallsCount = 0
    /// The mocked property with a getter and setter.
    var siteId: String {
        get {
            mockCalled = true
            siteIdGetCallsCount += 1
            return underlyingSiteId
        }
        set(value) {
            mockCalled = true
            siteIdSetCallsCount += 1
            underlyingSiteId = value
        }
    }

    public func resetMock() {
        siteIdGetCallsCount = 0
        siteIdSetCallsCount = 0
        showMessageCallsCount = 0
        showMessageReceivedArguments = nil
        showMessageReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - showMessage

    /// Number of times the function was called.
    @Atomic private(set) var showMessageCallsCount = 0
    /// `true` if the function was ever called.
    var showMessageCalled: Bool {
        showMessageCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var showMessageReceivedArguments: (message: Message, position: MessagePosition)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var showMessageReceivedInvocations: [(message: Message, position: MessagePosition)] = []
    /// Value to return from the mocked function.
    var showMessageReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `showMessageReturnValue`
     */
    var showMessageClosure: ((Message, MessagePosition) -> Bool)?

    /// Mocked function for `showMessage(_ message: Message, position: MessagePosition)`. Your opportunity to return a mocked value and check result of mock in test code.
    func showMessage(_ message: Message, position: MessagePosition) -> Bool {
        mockCalled = true
        showMessageCallsCount += 1
        showMessageReceivedArguments = (message: message, position: position)
        showMessageReceivedInvocations.append((message: message, position: position))
        return showMessageClosure.map { $0(message, position) } ?? showMessageReturnValue
    }
}

/**
 Class to easily create a mocked version of the `GistQueueNetwork` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
class GistQueueNetworkMock: GistQueueNetwork, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    var mockCalled: Bool = false //

    init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        requestCallsCount = 0
        requestReceivedArguments = nil
        requestReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - request

    var requestThrowableError: Error?
    /// Number of times the function was called.
    @Atomic private(set) var requestCallsCount = 0
    /// `true` if the function was ever called.
    var requestCalled: Bool {
        requestCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var requestReceivedArguments: (siteId: String, dataCenter: String, userToken: String?, request: GistNetworkRequest, completionHandler: (Result<GistNetworkResponse, Error>) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var requestReceivedInvocations: [(siteId: String, dataCenter: String, userToken: String?, request: GistNetworkRequest, completionHandler: (Result<GistNetworkResponse, Error>) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var requestClosure: ((String, String, String?, GistNetworkRequest, @escaping (Result<GistNetworkResponse, Error>) -> Void) throws -> Void)?

    /// Mocked function for `request(siteId: String, dataCenter: String, userToken: String?, request: GistNetworkRequest, completionHandler: @escaping (Result<GistNetworkResponse, Error>) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    func request(siteId: String, dataCenter: String, userToken: String?, request: GistNetworkRequest, completionHandler: @escaping (Result<GistNetworkResponse, Error>) -> Void) throws {
        if let error = requestThrowableError {
            throw error
        }
        mockCalled = true
        requestCallsCount += 1
        requestReceivedArguments = (siteId: siteId, dataCenter: dataCenter, userToken: userToken, request: request, completionHandler: completionHandler)
        requestReceivedInvocations.append((siteId: siteId, dataCenter: dataCenter, userToken: userToken, request: request, completionHandler: completionHandler))
        try requestClosure?(siteId, dataCenter, userToken, request, completionHandler)
    }
}

/**
 Class to easily create a mocked version of the `InAppEventListener` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class InAppEventListenerMock: InAppEventListener, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        messageShownCallsCount = 0
        messageShownReceivedArguments = nil
        messageShownReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        messageDismissedCallsCount = 0
        messageDismissedReceivedArguments = nil
        messageDismissedReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        errorWithMessageCallsCount = 0
        errorWithMessageReceivedArguments = nil
        errorWithMessageReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        messageActionTakenCallsCount = 0
        messageActionTakenReceivedArguments = nil
        messageActionTakenReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - messageShown

    /// Number of times the function was called.
    @Atomic public private(set) var messageShownCallsCount = 0
    /// `true` if the function was ever called.
    public var messageShownCalled: Bool {
        messageShownCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var messageShownReceivedArguments: InAppMessage?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var messageShownReceivedInvocations: [InAppMessage] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var messageShownClosure: ((InAppMessage) -> Void)?

    /// Mocked function for `messageShown(message: InAppMessage)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func messageShown(message: InAppMessage) {
        mockCalled = true
        messageShownCallsCount += 1
        messageShownReceivedArguments = message
        messageShownReceivedInvocations.append(message)
        messageShownClosure?(message)
    }

    // MARK: - messageDismissed

    /// Number of times the function was called.
    @Atomic public private(set) var messageDismissedCallsCount = 0
    /// `true` if the function was ever called.
    public var messageDismissedCalled: Bool {
        messageDismissedCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var messageDismissedReceivedArguments: InAppMessage?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var messageDismissedReceivedInvocations: [InAppMessage] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var messageDismissedClosure: ((InAppMessage) -> Void)?

    /// Mocked function for `messageDismissed(message: InAppMessage)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func messageDismissed(message: InAppMessage) {
        mockCalled = true
        messageDismissedCallsCount += 1
        messageDismissedReceivedArguments = message
        messageDismissedReceivedInvocations.append(message)
        messageDismissedClosure?(message)
    }

    // MARK: - errorWithMessage

    /// Number of times the function was called.
    @Atomic public private(set) var errorWithMessageCallsCount = 0
    /// `true` if the function was ever called.
    public var errorWithMessageCalled: Bool {
        errorWithMessageCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var errorWithMessageReceivedArguments: InAppMessage?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var errorWithMessageReceivedInvocations: [InAppMessage] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var errorWithMessageClosure: ((InAppMessage) -> Void)?

    /// Mocked function for `errorWithMessage(message: InAppMessage)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func errorWithMessage(message: InAppMessage) {
        mockCalled = true
        errorWithMessageCallsCount += 1
        errorWithMessageReceivedArguments = message
        errorWithMessageReceivedInvocations.append(message)
        errorWithMessageClosure?(message)
    }

    // MARK: - messageActionTaken

    /// Number of times the function was called.
    @Atomic public private(set) var messageActionTakenCallsCount = 0
    /// `true` if the function was ever called.
    public var messageActionTakenCalled: Bool {
        messageActionTakenCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var messageActionTakenReceivedArguments: (message: InAppMessage, actionValue: String, actionName: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var messageActionTakenReceivedInvocations: [(message: InAppMessage, actionValue: String, actionName: String)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var messageActionTakenClosure: ((InAppMessage, String, String) -> Void)?

    /// Mocked function for `messageActionTaken(message: InAppMessage, actionValue: String, actionName: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func messageActionTaken(message: InAppMessage, actionValue: String, actionName: String) {
        mockCalled = true
        messageActionTakenCallsCount += 1
        messageActionTakenReceivedArguments = (message: message, actionValue: actionValue, actionName: actionName)
        messageActionTakenReceivedInvocations.append((message: message, actionValue: actionValue, actionName: actionName))
        messageActionTakenClosure?(message, actionValue, actionName)
    }
}

/**
 Class to easily create a mocked version of the `InlineMessageUIViewDelegate` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class InlineMessageUIViewDelegateMock: InlineMessageUIViewDelegate, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        onActionClickCallsCount = 0
        onActionClickReceivedArguments = nil
        onActionClickReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - onActionClick

    /// Number of times the function was called.
    @Atomic public private(set) var onActionClickCallsCount = 0
    /// `true` if the function was ever called.
    public var onActionClickCalled: Bool {
        onActionClickCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var onActionClickReceivedArguments: (message: InAppMessage, actionValue: String, actionName: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var onActionClickReceivedInvocations: [(message: InAppMessage, actionValue: String, actionName: String)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var onActionClickClosure: ((InAppMessage, String, String) -> Void)?

    /// Mocked function for `onActionClick(message: InAppMessage, actionValue: String, actionName: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func onActionClick(message: InAppMessage, actionValue: String, actionName: String) {
        mockCalled = true
        onActionClickCallsCount += 1
        onActionClickReceivedArguments = (message: message, actionValue: actionValue, actionName: actionName)
        onActionClickReceivedInvocations.append((message: message, actionValue: actionValue, actionName: actionName))
        onActionClickClosure?(message, actionValue, actionName)
    }
}

/**
 Class to easily create a mocked version of the `InAppProvider` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
class InAppProviderMock: InAppProvider, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    var mockCalled: Bool = false //

    init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        initializeCallsCount = 0
        initializeReceivedArguments = nil
        initializeReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        setProfileIdentifierCallsCount = 0
        setProfileIdentifierReceivedArguments = nil
        setProfileIdentifierReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        clearIdentifyCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
        setRouteCallsCount = 0
        setRouteReceivedArguments = nil
        setRouteReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        dismissMessageCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - initialize

    /// Number of times the function was called.
    @Atomic private(set) var initializeCallsCount = 0
    /// `true` if the function was ever called.
    var initializeCalled: Bool {
        initializeCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var initializeReceivedArguments: (siteId: String, region: Region, delegate: GistDelegate, enableLogging: Bool)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var initializeReceivedInvocations: [(siteId: String, region: Region, delegate: GistDelegate, enableLogging: Bool)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var initializeClosure: ((String, Region, GistDelegate, Bool) -> Void)?

    /// Mocked function for `initialize(siteId: String, region: Region, delegate: GistDelegate, enableLogging: Bool)`. Your opportunity to return a mocked value and check result of mock in test code.
    func initialize(siteId: String, region: Region, delegate: GistDelegate, enableLogging: Bool) {
        mockCalled = true
        initializeCallsCount += 1
        initializeReceivedArguments = (siteId: siteId, region: region, delegate: delegate, enableLogging: enableLogging)
        initializeReceivedInvocations.append((siteId: siteId, region: region, delegate: delegate, enableLogging: enableLogging))
        initializeClosure?(siteId, region, delegate, enableLogging)
    }

    // MARK: - setProfileIdentifier

    /// Number of times the function was called.
    @Atomic private(set) var setProfileIdentifierCallsCount = 0
    /// `true` if the function was ever called.
    var setProfileIdentifierCalled: Bool {
        setProfileIdentifierCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var setProfileIdentifierReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var setProfileIdentifierReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var setProfileIdentifierClosure: ((String) -> Void)?

    /// Mocked function for `setProfileIdentifier(_ id: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    func setProfileIdentifier(_ id: String) {
        mockCalled = true
        setProfileIdentifierCallsCount += 1
        setProfileIdentifierReceivedArguments = id
        setProfileIdentifierReceivedInvocations.append(id)
        setProfileIdentifierClosure?(id)
    }

    // MARK: - clearIdentify

    /// Number of times the function was called.
    @Atomic private(set) var clearIdentifyCallsCount = 0
    /// `true` if the function was ever called.
    var clearIdentifyCalled: Bool {
        clearIdentifyCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var clearIdentifyClosure: (() -> Void)?

    /// Mocked function for `clearIdentify()`. Your opportunity to return a mocked value and check result of mock in test code.
    func clearIdentify() {
        mockCalled = true
        clearIdentifyCallsCount += 1
        clearIdentifyClosure?()
    }

    // MARK: - setRoute

    /// Number of times the function was called.
    @Atomic private(set) var setRouteCallsCount = 0
    /// `true` if the function was ever called.
    var setRouteCalled: Bool {
        setRouteCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var setRouteReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var setRouteReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var setRouteClosure: ((String) -> Void)?

    /// Mocked function for `setRoute(_ route: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    func setRoute(_ route: String) {
        mockCalled = true
        setRouteCallsCount += 1
        setRouteReceivedArguments = route
        setRouteReceivedInvocations.append(route)
        setRouteClosure?(route)
    }

    // MARK: - dismissMessage

    /// Number of times the function was called.
    @Atomic private(set) var dismissMessageCallsCount = 0
    /// `true` if the function was ever called.
    var dismissMessageCalled: Bool {
        dismissMessageCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var dismissMessageClosure: (() -> Void)?

    /// Mocked function for `dismissMessage()`. Your opportunity to return a mocked value and check result of mock in test code.
    func dismissMessage() {
        mockCalled = true
        dismissMessageCallsCount += 1
        dismissMessageClosure?()
    }
}

/**
 Class to easily create a mocked version of the `MessageQueueManager` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
class MessageQueueManagerMock: MessageQueueManager, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    var mockCalled: Bool = false //

    init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        clearLocalStoreCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
        getIntervalCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
        setIntervalCallsCount = 0
        setIntervalReceivedArguments = nil
        setIntervalReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        setupCallsCount = 0
        setupReceivedArguments = nil
        setupReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        fetchUserMessagesFromLocalStoreCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
        removeMessageFromLocalStoreCallsCount = 0
        removeMessageFromLocalStoreReceivedArguments = nil
        removeMessageFromLocalStoreReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        clearUserMessagesFromLocalStoreCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
        getInlineMessagesCallsCount = 0
        getInlineMessagesReceivedArguments = nil
        getInlineMessagesReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - clearLocalStore

    /// Number of times the function was called.
    @Atomic private(set) var clearLocalStoreCallsCount = 0
    /// `true` if the function was ever called.
    var clearLocalStoreCalled: Bool {
        clearLocalStoreCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var clearLocalStoreClosure: (() -> Void)?

    /// Mocked function for `clearLocalStore()`. Your opportunity to return a mocked value and check result of mock in test code.
    func clearLocalStore() {
        mockCalled = true
        clearLocalStoreCallsCount += 1
        clearLocalStoreClosure?()
    }

    // MARK: - getInterval

    /// Number of times the function was called.
    @Atomic private(set) var getIntervalCallsCount = 0
    /// `true` if the function was ever called.
    var getIntervalCalled: Bool {
        getIntervalCallsCount > 0
    }

    /// Value to return from the mocked function.
    var getIntervalReturnValue: Double!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getIntervalReturnValue`
     */
    var getIntervalClosure: (() -> Double)?

    /// Mocked function for `getInterval()`. Your opportunity to return a mocked value and check result of mock in test code.
    func getInterval() -> Double {
        mockCalled = true
        getIntervalCallsCount += 1
        return getIntervalClosure.map { $0() } ?? getIntervalReturnValue
    }

    // MARK: - setInterval

    /// Number of times the function was called.
    @Atomic private(set) var setIntervalCallsCount = 0
    /// `true` if the function was ever called.
    var setIntervalCalled: Bool {
        setIntervalCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var setIntervalReceivedArguments: Double?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var setIntervalReceivedInvocations: [Double] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var setIntervalClosure: ((Double) -> Void)?

    /// Mocked function for `setInterval(_ newInterval: Double)`. Your opportunity to return a mocked value and check result of mock in test code.
    func setInterval(_ newInterval: Double) {
        mockCalled = true
        setIntervalCallsCount += 1
        setIntervalReceivedArguments = newInterval
        setIntervalReceivedInvocations.append(newInterval)
        setIntervalClosure?(newInterval)
    }

    // MARK: - setup

    /// Number of times the function was called.
    @Atomic private(set) var setupCallsCount = 0
    /// `true` if the function was ever called.
    var setupCalled: Bool {
        setupCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var setupReceivedArguments: Bool?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var setupReceivedInvocations: [Bool] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var setupClosure: ((Bool) -> Void)?

    /// Mocked function for `setup(skipQueueCheck: Bool)`. Your opportunity to return a mocked value and check result of mock in test code.
    func setup(skipQueueCheck: Bool) {
        mockCalled = true
        setupCallsCount += 1
        setupReceivedArguments = skipQueueCheck
        setupReceivedInvocations.append(skipQueueCheck)
        setupClosure?(skipQueueCheck)
    }

    // MARK: - fetchUserMessagesFromLocalStore

    /// Number of times the function was called.
    @Atomic private(set) var fetchUserMessagesFromLocalStoreCallsCount = 0
    /// `true` if the function was ever called.
    var fetchUserMessagesFromLocalStoreCalled: Bool {
        fetchUserMessagesFromLocalStoreCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var fetchUserMessagesFromLocalStoreClosure: (() -> Void)?

    /// Mocked function for `fetchUserMessagesFromLocalStore()`. Your opportunity to return a mocked value and check result of mock in test code.
    func fetchUserMessagesFromLocalStore() {
        mockCalled = true
        fetchUserMessagesFromLocalStoreCallsCount += 1
        fetchUserMessagesFromLocalStoreClosure?()
    }

    // MARK: - removeMessageFromLocalStore

    /// Number of times the function was called.
    @Atomic private(set) var removeMessageFromLocalStoreCallsCount = 0
    /// `true` if the function was ever called.
    var removeMessageFromLocalStoreCalled: Bool {
        removeMessageFromLocalStoreCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var removeMessageFromLocalStoreReceivedArguments: Message?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var removeMessageFromLocalStoreReceivedInvocations: [Message] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var removeMessageFromLocalStoreClosure: ((Message) -> Void)?

    /// Mocked function for `removeMessageFromLocalStore(message: Message)`. Your opportunity to return a mocked value and check result of mock in test code.
    func removeMessageFromLocalStore(message: Message) {
        mockCalled = true
        removeMessageFromLocalStoreCallsCount += 1
        removeMessageFromLocalStoreReceivedArguments = message
        removeMessageFromLocalStoreReceivedInvocations.append(message)
        removeMessageFromLocalStoreClosure?(message)
    }

    // MARK: - clearUserMessagesFromLocalStore

    /// Number of times the function was called.
    @Atomic private(set) var clearUserMessagesFromLocalStoreCallsCount = 0
    /// `true` if the function was ever called.
    var clearUserMessagesFromLocalStoreCalled: Bool {
        clearUserMessagesFromLocalStoreCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var clearUserMessagesFromLocalStoreClosure: (() -> Void)?

    /// Mocked function for `clearUserMessagesFromLocalStore()`. Your opportunity to return a mocked value and check result of mock in test code.
    func clearUserMessagesFromLocalStore() {
        mockCalled = true
        clearUserMessagesFromLocalStoreCallsCount += 1
        clearUserMessagesFromLocalStoreClosure?()
    }

    // MARK: - getInlineMessages

    /// Number of times the function was called.
    @Atomic private(set) var getInlineMessagesCallsCount = 0
    /// `true` if the function was ever called.
    var getInlineMessagesCalled: Bool {
        getInlineMessagesCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var getInlineMessagesReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var getInlineMessagesReceivedInvocations: [String] = []
    /// Value to return from the mocked function.
    var getInlineMessagesReturnValue: [Message]!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getInlineMessagesReturnValue`
     */
    var getInlineMessagesClosure: ((String) -> [Message])?

    /// Mocked function for `getInlineMessages(forElementId elementId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    func getInlineMessages(forElementId elementId: String) -> [Message] {
        mockCalled = true
        getInlineMessagesCallsCount += 1
        getInlineMessagesReceivedArguments = elementId
        getInlineMessagesReceivedInvocations.append(elementId)
        return getInlineMessagesClosure.map { $0(elementId) } ?? getInlineMessagesReturnValue
    }
}

/**
 Class to easily create a mocked version of the `MessagingInAppInstance` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class MessagingInAppInstanceMock: MessagingInAppInstance, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        setEventListenerCallsCount = 0
        setEventListenerReceivedArguments = nil
        setEventListenerReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        dismissMessageCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - setEventListener

    /// Number of times the function was called.
    @Atomic public private(set) var setEventListenerCallsCount = 0
    /// `true` if the function was ever called.
    public var setEventListenerCalled: Bool {
        setEventListenerCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var setEventListenerReceivedArguments: InAppEventListener??
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var setEventListenerReceivedInvocations: [InAppEventListener?] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var setEventListenerClosure: ((InAppEventListener?) -> Void)?

    /// Mocked function for `setEventListener(_ eventListener: InAppEventListener?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func setEventListener(_ eventListener: InAppEventListener?) {
        mockCalled = true
        setEventListenerCallsCount += 1
        setEventListenerReceivedArguments = eventListener
        setEventListenerReceivedInvocations.append(eventListener)
        setEventListenerClosure?(eventListener)
    }

    // MARK: - dismissMessage

    /// Number of times the function was called.
    @Atomic public private(set) var dismissMessageCallsCount = 0
    /// `true` if the function was ever called.
    public var dismissMessageCalled: Bool {
        dismissMessageCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var dismissMessageClosure: (() -> Void)?

    /// Mocked function for `dismissMessage()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func dismissMessage() {
        mockCalled = true
        dismissMessageCallsCount += 1
        dismissMessageClosure?()
    }
}

// swiftlint:enable all
