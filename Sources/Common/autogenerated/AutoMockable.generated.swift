// Generated using Sourcery 2.0.3 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT
// swiftlint:disable all

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif
#if canImport(UserNotifications)
import UserNotifications
#endif

/**
 ######################################################
 Documentation
 ######################################################

 This automatically generated file you are viewing contains mock classes that you can use in your test suite.

 * How do you generate a new mock class?

 1. Mocks are generated from Swift protocols. So, you must make one.

 ```
 protocol FriendsRepository {
     func acceptFriendRequest<Attributes: Encodable>(attributes: Attributes, _ onComplete: @escaping () -> Void)
 }

 class AppFriendsRepository: FriendsRepository {
     ...
 }
 ```

 2. Have your new protocol extend `AutoMockable`:

 ```
 protocol FriendsRepository: AutoMockable {
     func acceptFriendRequest<Attributes: Encodable>(
         // sourcery:Type=Encodable
         attributes: Attributes,
         _ onComplete: @escaping () -> Void)
 }
 ```

 > Notice the use of `// sourcery:Type=Encodable` for the generic type parameter. Without this, the mock would
 fail to compile: `functionNameReceiveArguments = (Attributes)` because `Attributes` is unknown to this `var`.
 Instead, we give the parameter a different type to use for the mock. `Encodable` works in this case.
 It will require a cast in the test function code, however.

 3. Run the command `make generate` on your machine. The new mock should be added to this file.

 * How do you use the mocks in your test class?

 ```
 class ExampleViewModelTest: XCTestCase {
     var viewModel: ExampleViewModel!
     var exampleRepositoryMock: ExampleRepositoryMock!
     override func setUp() {
         exampleRepositoryMock = ExampleRepositoryMock()
         viewModel = AppExampleViewModel(exampleRepository: exampleRepositoryMock)
     }
 }
 ```

 Or, you may need to inject the mock in a different way using the DI.shared graph:

 ```
 class ExampleTest: XCTestCase {
     var exampleViewModelMock: ExampleViewModelMock!
     var example: Example!
     override func setUp() {
         exampleViewModelMock = ExampleViewModelMock()
         DI.shared.override(.exampleViewModel, value: exampleViewModelMock, forType: ExampleViewModel.self)
         example = Example()
     }
 }

 ```

 */

/**
 Class to easily create a mocked version of the `CustomerIOInstance` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class CustomerIOInstanceMock: CustomerIOInstance, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingProfileAttributes: [String: Any] = [:]
    /// `true` if the getter or setter of property is called at least once.
    public var profileAttributesCalled: Bool {
        profileAttributesGetCalled || profileAttributesSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var profileAttributesGetCalled: Bool {
        profileAttributesGetCallsCount > 0
    }

    public var profileAttributesGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var profileAttributesSetCalled: Bool {
        profileAttributesSetCallsCount > 0
    }

    public var profileAttributesSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var profileAttributes: [String: Any] {
        get {
            mockCalled = true
            profileAttributesGetCallsCount += 1
            return underlyingProfileAttributes
        }
        set(value) {
            mockCalled = true
            profileAttributesSetCallsCount += 1
            underlyingProfileAttributes = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingDeviceAttributes: [String: Any] = [:]
    /// `true` if the getter or setter of property is called at least once.
    public var deviceAttributesCalled: Bool {
        deviceAttributesGetCalled || deviceAttributesSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var deviceAttributesGetCalled: Bool {
        deviceAttributesGetCallsCount > 0
    }

    public var deviceAttributesGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var deviceAttributesSetCalled: Bool {
        deviceAttributesSetCallsCount > 0
    }

    public var deviceAttributesSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var deviceAttributes: [String: Any] {
        get {
            mockCalled = true
            deviceAttributesGetCallsCount += 1
            return underlyingDeviceAttributes
        }
        set(value) {
            mockCalled = true
            deviceAttributesSetCallsCount += 1
            underlyingDeviceAttributes = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingRegisteredDeviceToken: String? = nil
    /// `true` if the getter or setter of property is called at least once.
    public var registeredDeviceTokenCalled: Bool {
        registeredDeviceTokenGetCalled || registeredDeviceTokenSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var registeredDeviceTokenGetCalled: Bool {
        registeredDeviceTokenGetCallsCount > 0
    }

    public var registeredDeviceTokenGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var registeredDeviceTokenSetCalled: Bool {
        registeredDeviceTokenSetCallsCount > 0
    }

    public var registeredDeviceTokenSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var registeredDeviceToken: String? {
        get {
            mockCalled = true
            registeredDeviceTokenGetCallsCount += 1
            return underlyingRegisteredDeviceToken
        }
        set(value) {
            mockCalled = true
            registeredDeviceTokenSetCallsCount += 1
            underlyingRegisteredDeviceToken = value
        }
    }

    public func resetMock() {
        profileAttributesGetCallsCount = 0
        profileAttributesSetCallsCount = 0
        deviceAttributesGetCallsCount = 0
        deviceAttributesSetCallsCount = 0
        registeredDeviceToken = nil
        registeredDeviceTokenGetCallsCount = 0
        registeredDeviceTokenSetCallsCount = 0
        identifyCallsCount = 0
        identifyReceivedArguments = nil
        identifyReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        identifyEncodableReceivedArguments = nil
        identifyEncodableReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        clearIdentifyCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
        registerDeviceTokenCallsCount = 0
        registerDeviceTokenReceivedArguments = nil
        registerDeviceTokenReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        deleteDeviceTokenCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
        trackCallsCount = 0
        trackReceivedArguments = nil
        trackReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        trackEncodableReceivedArguments = nil
        trackEncodableReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        screenCallsCount = 0
        screenReceivedArguments = nil
        screenReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        screenEncodableReceivedArguments = nil
        screenEncodableReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        trackMetricCallsCount = 0
        trackMetricReceivedArguments = nil
        trackMetricReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - identify

    /// Number of times the function was called.
    @Atomic public private(set) var identifyCallsCount = 0
    /// `true` if the function was ever called.
    public var identifyCalled: Bool {
        identifyCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var identifyReceivedArguments: (userId: String, traits: [String: Any]?)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var identifyReceivedInvocations: [(userId: String, traits: [String: Any]?)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var identifyClosure: ((String, [String: Any]?) -> Void)?

    /// Mocked function for `identify(userId: String, traits: [String: Any]?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func identify(userId: String, traits: [String: Any]?) {
        mockCalled = true
        identifyCallsCount += 1
        identifyReceivedArguments = (userId: userId, traits: traits)
        identifyReceivedInvocations.append((userId: userId, traits: traits))
        identifyClosure?(userId, traits)
    }

    // MARK: - identify<RequestBody: Codable>

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var identifyEncodableReceivedArguments: (userId: String, traits: AnyEncodable)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var identifyEncodableReceivedInvocations: [(userId: String, traits: AnyEncodable)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var identifyEncodableClosure: ((String, AnyEncodable) -> Void)?

    /// Mocked function for `identify<RequestBody: Codable>(userId: String, traits: RequestBody?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func identify<RequestBody: Codable>(userId: String, traits: RequestBody?) {
        mockCalled = true
        identifyCallsCount += 1
        identifyEncodableReceivedArguments = (userId: userId, traits: AnyEncodable(traits))
        identifyEncodableReceivedInvocations.append((userId: userId, traits: AnyEncodable(traits)))
        identifyEncodableClosure?(userId, AnyEncodable(traits))
    }

    // MARK: - clearIdentify

    /// Number of times the function was called.
    @Atomic public private(set) var clearIdentifyCallsCount = 0
    /// `true` if the function was ever called.
    public var clearIdentifyCalled: Bool {
        clearIdentifyCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var clearIdentifyClosure: (() -> Void)?

    /// Mocked function for `clearIdentify()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func clearIdentify() {
        mockCalled = true
        clearIdentifyCallsCount += 1
        clearIdentifyClosure?()
    }

    // MARK: - registerDeviceToken

    /// Number of times the function was called.
    @Atomic public private(set) var registerDeviceTokenCallsCount = 0
    /// `true` if the function was ever called.
    public var registerDeviceTokenCalled: Bool {
        registerDeviceTokenCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var registerDeviceTokenReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var registerDeviceTokenReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var registerDeviceTokenClosure: ((String) -> Void)?

    /// Mocked function for `registerDeviceToken(_ deviceToken: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func registerDeviceToken(_ deviceToken: String) {
        mockCalled = true
        registerDeviceTokenCallsCount += 1
        registerDeviceTokenReceivedArguments = deviceToken
        registerDeviceTokenReceivedInvocations.append(deviceToken)
        registerDeviceTokenClosure?(deviceToken)
    }

    // MARK: - deleteDeviceToken

    /// Number of times the function was called.
    @Atomic public private(set) var deleteDeviceTokenCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteDeviceTokenCalled: Bool {
        deleteDeviceTokenCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var deleteDeviceTokenClosure: (() -> Void)?

    /// Mocked function for `deleteDeviceToken()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func deleteDeviceToken() {
        mockCalled = true
        deleteDeviceTokenCallsCount += 1
        deleteDeviceTokenClosure?()
    }

    // MARK: - track

    /// Number of times the function was called.
    @Atomic public private(set) var trackCallsCount = 0
    /// `true` if the function was ever called.
    public var trackCalled: Bool {
        trackCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var trackReceivedArguments: (name: String, properties: [String: Any]?)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var trackReceivedInvocations: [(name: String, properties: [String: Any]?)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var trackClosure: ((String, [String: Any]?) -> Void)?

    /// Mocked function for `track(name: String, properties: [String: Any]?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func track(name: String, properties: [String: Any]?) {
        mockCalled = true
        trackCallsCount += 1
        trackReceivedArguments = (name: name, properties: properties)
        trackReceivedInvocations.append((name: name, properties: properties))
        trackClosure?(name, properties)
    }

    // MARK: - track<RequestBody: Codable>

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var trackEncodableReceivedArguments: (name: String, properties: AnyEncodable)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var trackEncodableReceivedInvocations: [(name: String, properties: AnyEncodable)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var trackEncodableClosure: ((String, AnyEncodable) -> Void)?

    /// Mocked function for `track<RequestBody: Codable>(name: String, properties: RequestBody?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func track<RequestBody: Codable>(name: String, properties: RequestBody?) {
        mockCalled = true
        trackCallsCount += 1
        trackEncodableReceivedArguments = (name: name, properties: AnyEncodable(properties))
        trackEncodableReceivedInvocations.append((name: name, properties: AnyEncodable(properties)))
        trackEncodableClosure?(name, AnyEncodable(properties))
    }

    // MARK: - screen

    /// Number of times the function was called.
    @Atomic public private(set) var screenCallsCount = 0
    /// `true` if the function was ever called.
    public var screenCalled: Bool {
        screenCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var screenReceivedArguments: (title: String, properties: [String: Any]?)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var screenReceivedInvocations: [(title: String, properties: [String: Any]?)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var screenClosure: ((String, [String: Any]?) -> Void)?

    /// Mocked function for `screen(title: String, properties: [String: Any]?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func screen(title: String, properties: [String: Any]?) {
        mockCalled = true
        screenCallsCount += 1
        screenReceivedArguments = (title: title, properties: properties)
        screenReceivedInvocations.append((title: title, properties: properties))
        screenClosure?(title, properties)
    }

    // MARK: - screen<RequestBody: Codable>

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var screenEncodableReceivedArguments: (title: String, properties: AnyEncodable)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var screenEncodableReceivedInvocations: [(title: String, properties: AnyEncodable)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var screenEncodableClosure: ((String, AnyEncodable) -> Void)?

    /// Mocked function for `screen<RequestBody: Codable>(title: String, properties: RequestBody?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func screen<RequestBody: Codable>(title: String, properties: RequestBody?) {
        mockCalled = true
        screenCallsCount += 1
        screenEncodableReceivedArguments = (title: title, properties: AnyEncodable(properties))
        screenEncodableReceivedInvocations.append((title: title, properties: AnyEncodable(properties)))
        screenEncodableClosure?(title, AnyEncodable(properties))
    }

    // MARK: - trackMetric

    /// Number of times the function was called.
    @Atomic public private(set) var trackMetricCallsCount = 0
    /// `true` if the function was ever called.
    public var trackMetricCalled: Bool {
        trackMetricCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var trackMetricReceivedArguments: (deliveryID: String, event: Metric, deviceToken: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var trackMetricReceivedInvocations: [(deliveryID: String, event: Metric, deviceToken: String)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var trackMetricClosure: ((String, Metric, String) -> Void)?

    /// Mocked function for `trackMetric(deliveryID: String, event: Metric, deviceToken: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func trackMetric(deliveryID: String, event: Metric, deviceToken: String) {
        mockCalled = true
        trackMetricCallsCount += 1
        trackMetricReceivedArguments = (deliveryID: deliveryID, event: event, deviceToken: deviceToken)
        trackMetricReceivedInvocations.append((deliveryID: deliveryID, event: event, deviceToken: deviceToken))
        trackMetricClosure?(deliveryID, event, deviceToken)
    }
}

/**
 Class to easily create a mocked version of the `DeviceInfo` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class DeviceInfoMock: DeviceInfo, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingDeviceManufacturer: String!
    /// `true` if the getter or setter of property is called at least once.
    public var deviceManufacturerCalled: Bool {
        deviceManufacturerGetCalled || deviceManufacturerSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var deviceManufacturerGetCalled: Bool {
        deviceManufacturerGetCallsCount > 0
    }

    public var deviceManufacturerGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var deviceManufacturerSetCalled: Bool {
        deviceManufacturerSetCallsCount > 0
    }

    public var deviceManufacturerSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var deviceManufacturer: String {
        get {
            mockCalled = true
            deviceManufacturerGetCallsCount += 1
            return underlyingDeviceManufacturer
        }
        set(value) {
            mockCalled = true
            deviceManufacturerSetCallsCount += 1
            underlyingDeviceManufacturer = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingDeviceModel: String? = nil
    /// `true` if the getter or setter of property is called at least once.
    public var deviceModelCalled: Bool {
        deviceModelGetCalled || deviceModelSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var deviceModelGetCalled: Bool {
        deviceModelGetCallsCount > 0
    }

    public var deviceModelGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var deviceModelSetCalled: Bool {
        deviceModelSetCallsCount > 0
    }

    public var deviceModelSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var deviceModel: String? {
        get {
            mockCalled = true
            deviceModelGetCallsCount += 1
            return underlyingDeviceModel
        }
        set(value) {
            mockCalled = true
            deviceModelSetCallsCount += 1
            underlyingDeviceModel = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingOsVersion: String? = nil
    /// `true` if the getter or setter of property is called at least once.
    public var osVersionCalled: Bool {
        osVersionGetCalled || osVersionSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var osVersionGetCalled: Bool {
        osVersionGetCallsCount > 0
    }

    public var osVersionGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var osVersionSetCalled: Bool {
        osVersionSetCallsCount > 0
    }

    public var osVersionSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var osVersion: String? {
        get {
            mockCalled = true
            osVersionGetCallsCount += 1
            return underlyingOsVersion
        }
        set(value) {
            mockCalled = true
            osVersionSetCallsCount += 1
            underlyingOsVersion = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingOsName: String? = nil
    /// `true` if the getter or setter of property is called at least once.
    public var osNameCalled: Bool {
        osNameGetCalled || osNameSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var osNameGetCalled: Bool {
        osNameGetCallsCount > 0
    }

    public var osNameGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var osNameSetCalled: Bool {
        osNameSetCallsCount > 0
    }

    public var osNameSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var osName: String? {
        get {
            mockCalled = true
            osNameGetCallsCount += 1
            return underlyingOsName
        }
        set(value) {
            mockCalled = true
            osNameSetCallsCount += 1
            underlyingOsName = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingCustomerAppName: String!
    /// `true` if the getter or setter of property is called at least once.
    public var customerAppNameCalled: Bool {
        customerAppNameGetCalled || customerAppNameSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var customerAppNameGetCalled: Bool {
        customerAppNameGetCallsCount > 0
    }

    public var customerAppNameGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var customerAppNameSetCalled: Bool {
        customerAppNameSetCallsCount > 0
    }

    public var customerAppNameSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var customerAppName: String {
        get {
            mockCalled = true
            customerAppNameGetCallsCount += 1
            return underlyingCustomerAppName
        }
        set(value) {
            mockCalled = true
            customerAppNameSetCallsCount += 1
            underlyingCustomerAppName = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingCustomerAppVersion: String!
    /// `true` if the getter or setter of property is called at least once.
    public var customerAppVersionCalled: Bool {
        customerAppVersionGetCalled || customerAppVersionSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var customerAppVersionGetCalled: Bool {
        customerAppVersionGetCallsCount > 0
    }

    public var customerAppVersionGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var customerAppVersionSetCalled: Bool {
        customerAppVersionSetCallsCount > 0
    }

    public var customerAppVersionSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var customerAppVersion: String {
        get {
            mockCalled = true
            customerAppVersionGetCallsCount += 1
            return underlyingCustomerAppVersion
        }
        set(value) {
            mockCalled = true
            customerAppVersionSetCallsCount += 1
            underlyingCustomerAppVersion = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingCustomerBundleId: String!
    /// `true` if the getter or setter of property is called at least once.
    public var customerBundleIdCalled: Bool {
        customerBundleIdGetCalled || customerBundleIdSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var customerBundleIdGetCalled: Bool {
        customerBundleIdGetCallsCount > 0
    }

    public var customerBundleIdGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var customerBundleIdSetCalled: Bool {
        customerBundleIdSetCallsCount > 0
    }

    public var customerBundleIdSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var customerBundleId: String {
        get {
            mockCalled = true
            customerBundleIdGetCallsCount += 1
            return underlyingCustomerBundleId
        }
        set(value) {
            mockCalled = true
            customerBundleIdSetCallsCount += 1
            underlyingCustomerBundleId = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingDeviceLocale: String!
    /// `true` if the getter or setter of property is called at least once.
    public var deviceLocaleCalled: Bool {
        deviceLocaleGetCalled || deviceLocaleSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var deviceLocaleGetCalled: Bool {
        deviceLocaleGetCallsCount > 0
    }

    public var deviceLocaleGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var deviceLocaleSetCalled: Bool {
        deviceLocaleSetCallsCount > 0
    }

    public var deviceLocaleSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var deviceLocale: String {
        get {
            mockCalled = true
            deviceLocaleGetCallsCount += 1
            return underlyingDeviceLocale
        }
        set(value) {
            mockCalled = true
            deviceLocaleSetCallsCount += 1
            underlyingDeviceLocale = value
        }
    }

    public func resetMock() {
        deviceManufacturerGetCallsCount = 0
        deviceManufacturerSetCallsCount = 0
        deviceModel = nil
        deviceModelGetCallsCount = 0
        deviceModelSetCallsCount = 0
        osVersion = nil
        osVersionGetCallsCount = 0
        osVersionSetCallsCount = 0
        osName = nil
        osNameGetCallsCount = 0
        osNameSetCallsCount = 0
        customerAppNameGetCallsCount = 0
        customerAppNameSetCallsCount = 0
        customerAppVersionGetCallsCount = 0
        customerAppVersionSetCallsCount = 0
        customerBundleIdGetCallsCount = 0
        customerBundleIdSetCallsCount = 0
        deviceLocaleGetCallsCount = 0
        deviceLocaleSetCallsCount = 0
        isPushSubscribedCallsCount = 0
        isPushSubscribedReceivedArguments = nil
        isPushSubscribedReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - isPushSubscribed

    /// Number of times the function was called.
    @Atomic public private(set) var isPushSubscribedCallsCount = 0
    /// `true` if the function was ever called.
    public var isPushSubscribedCalled: Bool {
        isPushSubscribedCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var isPushSubscribedReceivedArguments: ((Bool) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var isPushSubscribedReceivedInvocations: [(Bool) -> Void] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var isPushSubscribedClosure: ((@escaping (Bool) -> Void) -> Void)?

    /// Mocked function for `isPushSubscribed(completion: @escaping (Bool) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func isPushSubscribed(completion: @escaping (Bool) -> Void) {
        mockCalled = true
        isPushSubscribedCallsCount += 1
        isPushSubscribedReceivedArguments = completion
        isPushSubscribedReceivedInvocations.append(completion)
        isPushSubscribedClosure?(completion)
    }
}

/**
 Class to easily create a mocked version of the `DeviceMetricsGrabber` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
class DeviceMetricsGrabberMock: DeviceMetricsGrabber, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    var mockCalled: Bool = false //

    init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    var underlyingAppBundleId: String? = nil
    /// `true` if the getter or setter of property is called at least once.
    var appBundleIdCalled: Bool {
        appBundleIdGetCalled || appBundleIdSetCalled
    }

    /// `true` if the getter called on the property at least once.
    var appBundleIdGetCalled: Bool {
        appBundleIdGetCallsCount > 0
    }

    var appBundleIdGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    var appBundleIdSetCalled: Bool {
        appBundleIdSetCallsCount > 0
    }

    var appBundleIdSetCallsCount = 0
    /// The mocked property with a getter and setter.
    var appBundleId: String? {
        get {
            mockCalled = true
            appBundleIdGetCallsCount += 1
            return underlyingAppBundleId
        }
        set(value) {
            mockCalled = true
            appBundleIdSetCallsCount += 1
            underlyingAppBundleId = value
        }
    }

    public func resetMock() {
        appBundleId = nil
        appBundleIdGetCallsCount = 0
        appBundleIdSetCallsCount = 0
    }
}

/**
 Class to easily create a mocked version of the `EventBus` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class EventBusMock: EventBus, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        postCallsCount = 0
        postReceivedArguments = nil
        postReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        addObserverCallsCount = 0
        addObserverReceivedArguments = nil
        addObserverReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        removeObserverCallsCount = 0
        removeObserverReceivedArguments = nil
        removeObserverReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - post

    /// Number of times the function was called.
    @Atomic public private(set) var postCallsCount = 0
    /// `true` if the function was ever called.
    public var postCalled: Bool {
        postCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var postReceivedArguments: AnyEventRepresentable?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var postReceivedInvocations: [AnyEventRepresentable] = []
    /// Value to return from the mocked function.
    public var postReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `postReturnValue`
     */
    public var postClosure: ((AnyEventRepresentable) -> Bool)?

    /// Mocked function for `post(_ event: AnyEventRepresentable)`. Your opportunity to return a mocked value and check result of mock in test code.
    @discardableResult
    public func post(_ event: AnyEventRepresentable) -> Bool {
        mockCalled = true
        postCallsCount += 1
        postReceivedArguments = event
        postReceivedInvocations.append(event)
        return postClosure.map { $0(event) } ?? postReturnValue
    }

    // MARK: - addObserver

    /// Number of times the function was called.
    @Atomic public private(set) var addObserverCallsCount = 0
    /// `true` if the function was ever called.
    public var addObserverCalled: Bool {
        addObserverCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var addObserverReceivedArguments: (eventType: String, action: (AnyEventRepresentable) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var addObserverReceivedInvocations: [(eventType: String, action: (AnyEventRepresentable) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var addObserverClosure: ((String, @escaping (AnyEventRepresentable) -> Void) -> Void)?

    /// Mocked function for `addObserver(_ eventType: String, action: @escaping (AnyEventRepresentable) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func addObserver(_ eventType: String, action: @escaping (AnyEventRepresentable) -> Void) {
        mockCalled = true
        addObserverCallsCount += 1
        addObserverReceivedArguments = (eventType: eventType, action: action)
        addObserverReceivedInvocations.append((eventType: eventType, action: action))
        addObserverClosure?(eventType, action)
    }

    // MARK: - removeObserver

    /// Number of times the function was called.
    @Atomic public private(set) var removeObserverCallsCount = 0
    /// `true` if the function was ever called.
    public var removeObserverCalled: Bool {
        removeObserverCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var removeObserverReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var removeObserverReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var removeObserverClosure: ((String) -> Void)?

    /// Mocked function for `removeObserver(for eventType: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func removeObserver(for eventType: String) {
        mockCalled = true
        removeObserverCallsCount += 1
        removeObserverReceivedArguments = eventType
        removeObserverReceivedInvocations.append(eventType)
        removeObserverClosure?(eventType)
    }
}

/**
 Class to easily create a mocked version of the `EventCache` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class EventCacheMock: EventCache, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        addEventCallsCount = 0
        addEventReceivedArguments = nil
        addEventReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        storeEventsCallsCount = 0
        storeEventsReceivedArguments = nil
        storeEventsReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        getEventCallsCount = 0
        getEventReceivedArguments = nil
        getEventReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        removeAllEventsForKeyCallsCount = 0
        removeAllEventsForKeyReceivedArguments = nil
        removeAllEventsForKeyReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - addEvent

    /// Number of times the function was called.
    @Atomic public private(set) var addEventCallsCount = 0
    /// `true` if the function was ever called.
    public var addEventCalled: Bool {
        addEventCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var addEventReceivedArguments: AnyEventRepresentable?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var addEventReceivedInvocations: [AnyEventRepresentable] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var addEventClosure: ((AnyEventRepresentable) -> Void)?

    /// Mocked function for `addEvent(event: AnyEventRepresentable)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func addEvent(event: AnyEventRepresentable) {
        mockCalled = true
        addEventCallsCount += 1
        addEventReceivedArguments = event
        addEventReceivedInvocations.append(event)
        addEventClosure?(event)
    }

    // MARK: - storeEvents

    /// Number of times the function was called.
    @Atomic public private(set) var storeEventsCallsCount = 0
    /// `true` if the function was ever called.
    public var storeEventsCalled: Bool {
        storeEventsCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var storeEventsReceivedArguments: (events: [AnyEventRepresentable], key: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var storeEventsReceivedInvocations: [(events: [AnyEventRepresentable], key: String)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var storeEventsClosure: (([AnyEventRepresentable], String) -> Void)?

    /// Mocked function for `storeEvents(_ events: [AnyEventRepresentable], forKey key: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func storeEvents(_ events: [AnyEventRepresentable], forKey key: String) {
        mockCalled = true
        storeEventsCallsCount += 1
        storeEventsReceivedArguments = (events: events, key: key)
        storeEventsReceivedInvocations.append((events: events, key: key))
        storeEventsClosure?(events, key)
    }

    // MARK: - getEvent

    /// Number of times the function was called.
    @Atomic public private(set) var getEventCallsCount = 0
    /// `true` if the function was ever called.
    public var getEventCalled: Bool {
        getEventCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var getEventReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var getEventReceivedInvocations: [String] = []
    /// Value to return from the mocked function.
    public var getEventReturnValue: [AnyEventRepresentable]!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getEventReturnValue`
     */
    public var getEventClosure: ((String) -> [AnyEventRepresentable])?

    /// Mocked function for `getEvent(_ key: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func getEvent(_ key: String) -> [AnyEventRepresentable] {
        mockCalled = true
        getEventCallsCount += 1
        getEventReceivedArguments = key
        getEventReceivedInvocations.append(key)
        return getEventClosure.map { $0(key) } ?? getEventReturnValue
    }

    // MARK: - removeAllEventsForKey

    /// Number of times the function was called.
    @Atomic public private(set) var removeAllEventsForKeyCallsCount = 0
    /// `true` if the function was ever called.
    public var removeAllEventsForKeyCalled: Bool {
        removeAllEventsForKeyCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var removeAllEventsForKeyReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var removeAllEventsForKeyReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var removeAllEventsForKeyClosure: ((String) -> Void)?

    /// Mocked function for `removeAllEventsForKey(_ key: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func removeAllEventsForKey(_ key: String) {
        mockCalled = true
        removeAllEventsForKeyCallsCount += 1
        removeAllEventsForKeyReceivedArguments = key
        removeAllEventsForKeyReceivedInvocations.append(key)
        removeAllEventsForKeyClosure?(key)
    }
}

/**
 Class to easily create a mocked version of the `EventStorage` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class EventStorageMock: EventStorage, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        storeCallsCount = 0
        storeReceivedArguments = nil
        storeReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        retrieveCallsCount = 0
        retrieveReceivedArguments = nil
        retrieveReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        loadEventsCallsCount = 0
        loadEventsReceivedArguments = nil
        loadEventsReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        removeCallsCount = 0
        removeReceivedArguments = nil
        removeReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        removeAllCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - store

    var storeThrowableError: Error?
    /// Number of times the function was called.
    @Atomic public private(set) var storeCallsCount = 0
    /// `true` if the function was ever called.
    public var storeCalled: Bool {
        storeCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var storeReceivedArguments: AnyEventRepresentable?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var storeReceivedInvocations: [AnyEventRepresentable] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var storeClosure: ((AnyEventRepresentable) throws -> Void)?

    /// Mocked function for `store(event: AnyEventRepresentable)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func store(event: AnyEventRepresentable) throws {
        if let error = storeThrowableError {
            throw error
        }
        mockCalled = true
        storeCallsCount += 1
        storeReceivedArguments = event
        storeReceivedInvocations.append(event)
        try storeClosure?(event)
    }

    // MARK: - retrieve

    var retrieveThrowableError: Error?
    /// Number of times the function was called.
    @Atomic public private(set) var retrieveCallsCount = 0
    /// `true` if the function was ever called.
    public var retrieveCalled: Bool {
        retrieveCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var retrieveReceivedArguments: (eventType: String, storageId: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var retrieveReceivedInvocations: [(eventType: String, storageId: String)] = []
    /// Value to return from the mocked function.
    public var retrieveReturnValue: AnyEventRepresentable?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `retrieveReturnValue`
     */
    public var retrieveClosure: ((String, String) throws -> AnyEventRepresentable?)?

    /// Mocked function for `retrieve(eventType: String, storageId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func retrieve(eventType: String, storageId: String) throws -> AnyEventRepresentable? {
        if let error = retrieveThrowableError {
            throw error
        }
        mockCalled = true
        retrieveCallsCount += 1
        retrieveReceivedArguments = (eventType: eventType, storageId: storageId)
        retrieveReceivedInvocations.append((eventType: eventType, storageId: storageId))
        return try retrieveClosure.map { try $0(eventType, storageId) } ?? retrieveReturnValue
    }

    // MARK: - loadEvents

    var loadEventsThrowableError: Error?
    /// Number of times the function was called.
    @Atomic public private(set) var loadEventsCallsCount = 0
    /// `true` if the function was ever called.
    public var loadEventsCalled: Bool {
        loadEventsCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var loadEventsReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var loadEventsReceivedInvocations: [String] = []
    /// Value to return from the mocked function.
    public var loadEventsReturnValue: [AnyEventRepresentable]!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `loadEventsReturnValue`
     */
    public var loadEventsClosure: ((String) throws -> [AnyEventRepresentable])?

    /// Mocked function for `loadEvents(ofType type: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func loadEvents(ofType type: String) throws -> [AnyEventRepresentable] {
        if let error = loadEventsThrowableError {
            throw error
        }
        mockCalled = true
        loadEventsCallsCount += 1
        loadEventsReceivedArguments = type
        loadEventsReceivedInvocations.append(type)
        return try loadEventsClosure.map { try $0(type) } ?? loadEventsReturnValue
    }

    // MARK: - remove

    /// Number of times the function was called.
    @Atomic public private(set) var removeCallsCount = 0
    /// `true` if the function was ever called.
    public var removeCalled: Bool {
        removeCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var removeReceivedArguments: (eventType: String, storageId: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var removeReceivedInvocations: [(eventType: String, storageId: String)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var removeClosure: ((String, String) -> Void)?

    /// Mocked function for `remove(ofType eventType: String, withStorageId storageId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func remove(ofType eventType: String, withStorageId storageId: String) {
        mockCalled = true
        removeCallsCount += 1
        removeReceivedArguments = (eventType: eventType, storageId: storageId)
        removeReceivedInvocations.append((eventType: eventType, storageId: storageId))
        removeClosure?(eventType, storageId)
    }

    // MARK: - removeAll

    /// Number of times the function was called.
    @Atomic public private(set) var removeAllCallsCount = 0
    /// `true` if the function was ever called.
    public var removeAllCalled: Bool {
        removeAllCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var removeAllClosure: (() -> Void)?

    /// Mocked function for `removeAll()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func removeAll() {
        mockCalled = true
        removeAllCallsCount += 1
        removeAllClosure?()
    }
}

/**
 Class to easily create a mocked version of the `FileStorage` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class FileStorageMock: FileStorage, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        saveCallsCount = 0
        saveReceivedArguments = nil
        saveReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        getCallsCount = 0
        getReceivedArguments = nil
        getReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        deleteCallsCount = 0
        deleteReceivedArguments = nil
        deleteReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - save

    /// Number of times the function was called.
    @Atomic public private(set) var saveCallsCount = 0
    /// `true` if the function was ever called.
    public var saveCalled: Bool {
        saveCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var saveReceivedArguments: (siteId: String, type: FileType, contents: Data, fileId: String?)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var saveReceivedInvocations: [(siteId: String, type: FileType, contents: Data, fileId: String?)] = []
    /// Value to return from the mocked function.
    public var saveReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `saveReturnValue`
     */
    public var saveClosure: ((String, FileType, Data, String?) -> Bool)?

    /// Mocked function for `save(siteId: String, type: FileType, contents: Data, fileId: String?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func save(siteId: String, type: FileType, contents: Data, fileId: String?) -> Bool {
        mockCalled = true
        saveCallsCount += 1
        saveReceivedArguments = (siteId: siteId, type: type, contents: contents, fileId: fileId)
        saveReceivedInvocations.append((siteId: siteId, type: type, contents: contents, fileId: fileId))
        return saveClosure.map { $0(siteId, type, contents, fileId) } ?? saveReturnValue
    }

    // MARK: - get

    /// Number of times the function was called.
    @Atomic public private(set) var getCallsCount = 0
    /// `true` if the function was ever called.
    public var getCalled: Bool {
        getCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var getReceivedArguments: (siteId: String, type: FileType, fileId: String?)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var getReceivedInvocations: [(siteId: String, type: FileType, fileId: String?)] = []
    /// Value to return from the mocked function.
    public var getReturnValue: Data?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getReturnValue`
     */
    public var getClosure: ((String, FileType, String?) -> Data?)?

    /// Mocked function for `get(siteId: String, type: FileType, fileId: String?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func get(siteId: String, type: FileType, fileId: String?) -> Data? {
        mockCalled = true
        getCallsCount += 1
        getReceivedArguments = (siteId: siteId, type: type, fileId: fileId)
        getReceivedInvocations.append((siteId: siteId, type: type, fileId: fileId))
        return getClosure.map { $0(siteId, type, fileId) } ?? getReturnValue
    }

    // MARK: - delete

    /// Number of times the function was called.
    @Atomic public private(set) var deleteCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteCalled: Bool {
        deleteCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var deleteReceivedArguments: (siteId: String, type: FileType, fileId: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var deleteReceivedInvocations: [(siteId: String, type: FileType, fileId: String)] = []
    /// Value to return from the mocked function.
    public var deleteReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `deleteReturnValue`
     */
    public var deleteClosure: ((String, FileType, String) -> Bool)?

    /// Mocked function for `delete(siteId: String, type: FileType, fileId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func delete(siteId: String, type: FileType, fileId: String) -> Bool {
        mockCalled = true
        deleteCallsCount += 1
        deleteReceivedArguments = (siteId: siteId, type: type, fileId: fileId)
        deleteReceivedInvocations.append((siteId: siteId, type: type, fileId: fileId))
        return deleteClosure.map { $0(siteId, type, fileId) } ?? deleteReturnValue
    }
}

/**
 Class to easily create a mocked version of the `GlobalDataStore` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class GlobalDataStoreMock: GlobalDataStore, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingPushDeviceToken: String? = nil
    /// `true` if the getter or setter of property is called at least once.
    public var pushDeviceTokenCalled: Bool {
        pushDeviceTokenGetCalled || pushDeviceTokenSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var pushDeviceTokenGetCalled: Bool {
        pushDeviceTokenGetCallsCount > 0
    }

    public var pushDeviceTokenGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var pushDeviceTokenSetCalled: Bool {
        pushDeviceTokenSetCallsCount > 0
    }

    public var pushDeviceTokenSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var pushDeviceToken: String? {
        get {
            mockCalled = true
            pushDeviceTokenGetCallsCount += 1
            return underlyingPushDeviceToken
        }
        set(value) {
            mockCalled = true
            pushDeviceTokenSetCallsCount += 1
            underlyingPushDeviceToken = value
        }
    }

    public func resetMock() {
        pushDeviceToken = nil
        pushDeviceTokenGetCallsCount = 0
        pushDeviceTokenSetCallsCount = 0
        deleteAllCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - deleteAll

    /// Number of times the function was called.
    @Atomic public private(set) var deleteAllCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteAllCalled: Bool {
        deleteAllCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var deleteAllClosure: (() -> Void)?

    /// Mocked function for `deleteAll()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func deleteAll() {
        mockCalled = true
        deleteAllCallsCount += 1
        deleteAllClosure?()
    }
}

/**
 Class to easily create a mocked version of the `HttpClient` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class HttpClientMock: HttpClient, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        requestCallsCount = 0
        requestReceivedArguments = nil
        requestReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        downloadFileCallsCount = 0
        downloadFileReceivedArguments = nil
        downloadFileReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        cancelCallsCount = 0
        cancelReceivedArguments = nil
        cancelReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - request

    /// Number of times the function was called.
    @Atomic public private(set) var requestCallsCount = 0
    /// `true` if the function was ever called.
    public var requestCalled: Bool {
        requestCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var requestReceivedArguments: (params: HttpRequestParams, onComplete: (Result<Data, HttpRequestError>) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var requestReceivedInvocations: [(params: HttpRequestParams, onComplete: (Result<Data, HttpRequestError>) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var requestClosure: ((HttpRequestParams, @escaping (Result<Data, HttpRequestError>) -> Void) -> Void)?

    /// Mocked function for `request(_ params: HttpRequestParams, onComplete: @escaping (Result<Data, HttpRequestError>) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func request(_ params: HttpRequestParams, onComplete: @escaping (Result<Data, HttpRequestError>) -> Void) {
        mockCalled = true
        requestCallsCount += 1
        requestReceivedArguments = (params: params, onComplete: onComplete)
        requestReceivedInvocations.append((params: params, onComplete: onComplete))
        requestClosure?(params, onComplete)
    }

    // MARK: - downloadFile

    /// Number of times the function was called.
    @Atomic public private(set) var downloadFileCallsCount = 0
    /// `true` if the function was ever called.
    public var downloadFileCalled: Bool {
        downloadFileCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var downloadFileReceivedArguments: (url: URL, fileType: DownloadFileType, onComplete: (URL?) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var downloadFileReceivedInvocations: [(url: URL, fileType: DownloadFileType, onComplete: (URL?) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var downloadFileClosure: ((URL, DownloadFileType, @escaping (URL?) -> Void) -> Void)?

    /// Mocked function for `downloadFile(url: URL, fileType: DownloadFileType, onComplete: @escaping (URL?) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func downloadFile(url: URL, fileType: DownloadFileType, onComplete: @escaping (URL?) -> Void) {
        mockCalled = true
        downloadFileCallsCount += 1
        downloadFileReceivedArguments = (url: url, fileType: fileType, onComplete: onComplete)
        downloadFileReceivedInvocations.append((url: url, fileType: fileType, onComplete: onComplete))
        downloadFileClosure?(url, fileType, onComplete)
    }

    // MARK: - cancel

    /// Number of times the function was called.
    @Atomic public private(set) var cancelCallsCount = 0
    /// `true` if the function was ever called.
    public var cancelCalled: Bool {
        cancelCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var cancelReceivedArguments: Bool?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var cancelReceivedInvocations: [Bool] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var cancelClosure: ((Bool) -> Void)?

    /// Mocked function for `cancel(finishTasks: Bool)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func cancel(finishTasks: Bool) {
        mockCalled = true
        cancelCallsCount += 1
        cancelReceivedArguments = finishTasks
        cancelReceivedInvocations.append(finishTasks)
        cancelClosure?(finishTasks)
    }
}

/**
 Class to easily create a mocked version of the `HttpRequestRunner` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class HttpRequestRunnerMock: HttpRequestRunner, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        requestCallsCount = 0
        requestReceivedArguments = nil
        requestReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        downloadFileCallsCount = 0
        downloadFileReceivedArguments = nil
        downloadFileReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - request

    /// Number of times the function was called.
    @Atomic public private(set) var requestCallsCount = 0
    /// `true` if the function was ever called.
    public var requestCalled: Bool {
        requestCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var requestReceivedArguments: (params: HttpRequestParams, session: URLSession, onComplete: (Data?, HTTPURLResponse?, Error?) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var requestReceivedInvocations: [(params: HttpRequestParams, session: URLSession, onComplete: (Data?, HTTPURLResponse?, Error?) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var requestClosure: ((HttpRequestParams, URLSession, @escaping (Data?, HTTPURLResponse?, Error?) -> Void) -> Void)?

    /// Mocked function for `request(params: HttpRequestParams, session: URLSession, onComplete: @escaping (Data?, HTTPURLResponse?, Error?) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func request(params: HttpRequestParams, session: URLSession, onComplete: @escaping (Data?, HTTPURLResponse?, Error?) -> Void) {
        mockCalled = true
        requestCallsCount += 1
        requestReceivedArguments = (params: params, session: session, onComplete: onComplete)
        requestReceivedInvocations.append((params: params, session: session, onComplete: onComplete))
        requestClosure?(params, session, onComplete)
    }

    // MARK: - downloadFile

    /// Number of times the function was called.
    @Atomic public private(set) var downloadFileCallsCount = 0
    /// `true` if the function was ever called.
    public var downloadFileCalled: Bool {
        downloadFileCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var downloadFileReceivedArguments: (url: URL, fileType: DownloadFileType, session: URLSession, onComplete: (URL?) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var downloadFileReceivedInvocations: [(url: URL, fileType: DownloadFileType, session: URLSession, onComplete: (URL?) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var downloadFileClosure: ((URL, DownloadFileType, URLSession, @escaping (URL?) -> Void) -> Void)?

    /// Mocked function for `downloadFile(url: URL, fileType: DownloadFileType, session: URLSession, onComplete: @escaping (URL?) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func downloadFile(url: URL, fileType: DownloadFileType, session: URLSession, onComplete: @escaping (URL?) -> Void) {
        mockCalled = true
        downloadFileCallsCount += 1
        downloadFileReceivedArguments = (url: url, fileType: fileType, session: session, onComplete: onComplete)
        downloadFileReceivedInvocations.append((url: url, fileType: fileType, session: session, onComplete: onComplete))
        downloadFileClosure?(url, fileType, session, onComplete)
    }
}

/**
 Class to easily create a mocked version of the `Logger` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class LoggerMock: Logger, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingLogLevel: CioLogLevel!
    /// `true` if the getter or setter of property is called at least once.
    public var logLevelCalled: Bool {
        logLevelGetCalled || logLevelSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var logLevelGetCalled: Bool {
        logLevelGetCallsCount > 0
    }

    public var logLevelGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var logLevelSetCalled: Bool {
        logLevelSetCallsCount > 0
    }

    public var logLevelSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var logLevel: CioLogLevel {
        get {
            mockCalled = true
            logLevelGetCallsCount += 1
            return underlyingLogLevel
        }
        set(value) {
            mockCalled = true
            logLevelSetCallsCount += 1
            underlyingLogLevel = value
        }
    }

    public func resetMock() {
        logLevelGetCallsCount = 0
        logLevelSetCallsCount = 0
        setLogDispatcherCallsCount = 0
        setLogDispatcherReceivedArguments = nil
        setLogDispatcherReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        setLogLevelCallsCount = 0
        setLogLevelReceivedArguments = nil
        setLogLevelReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        debugCallsCount = 0
        debugReceivedArguments = nil
        debugReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        infoCallsCount = 0
        infoReceivedArguments = nil
        infoReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        errorCallsCount = 0
        errorReceivedArguments = nil
        errorReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - setLogDispatcher

    /// Number of times the function was called.
    @Atomic public private(set) var setLogDispatcherCallsCount = 0
    /// `true` if the function was ever called.
    public var setLogDispatcherCalled: Bool {
        setLogDispatcherCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var setLogDispatcherReceivedArguments: ((CioLogLevel, String) -> Void)??
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var setLogDispatcherReceivedInvocations: [((CioLogLevel, String) -> Void)?] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var setLogDispatcherClosure: ((((CioLogLevel, String) -> Void)?) -> Void)?

    /// Mocked function for `setLogDispatcher(_ dispatcher: ((CioLogLevel, String) -> Void)?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func setLogDispatcher(_ dispatcher: ((CioLogLevel, String) -> Void)?) {
        mockCalled = true
        setLogDispatcherCallsCount += 1
        setLogDispatcherReceivedArguments = dispatcher
        setLogDispatcherReceivedInvocations.append(dispatcher)
        setLogDispatcherClosure?(dispatcher)
    }

    // MARK: - setLogLevel

    /// Number of times the function was called.
    @Atomic public private(set) var setLogLevelCallsCount = 0
    /// `true` if the function was ever called.
    public var setLogLevelCalled: Bool {
        setLogLevelCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var setLogLevelReceivedArguments: CioLogLevel?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var setLogLevelReceivedInvocations: [CioLogLevel] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var setLogLevelClosure: ((CioLogLevel) -> Void)?

    /// Mocked function for `setLogLevel(_ level: CioLogLevel)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func setLogLevel(_ level: CioLogLevel) {
        mockCalled = true
        setLogLevelCallsCount += 1
        setLogLevelReceivedArguments = level
        setLogLevelReceivedInvocations.append(level)
        setLogLevelClosure?(level)
    }

    // MARK: - debug

    /// Number of times the function was called.
    @Atomic public private(set) var debugCallsCount = 0
    /// `true` if the function was ever called.
    public var debugCalled: Bool {
        debugCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var debugReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var debugReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var debugClosure: ((String) -> Void)?

    /// Mocked function for `debug(_ message: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func debug(_ message: String) {
        mockCalled = true
        debugCallsCount += 1
        debugReceivedArguments = message
        debugReceivedInvocations.append(message)
        debugClosure?(message)
    }

    // MARK: - info

    /// Number of times the function was called.
    @Atomic public private(set) var infoCallsCount = 0
    /// `true` if the function was ever called.
    public var infoCalled: Bool {
        infoCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var infoReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var infoReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var infoClosure: ((String) -> Void)?

    /// Mocked function for `info(_ message: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func info(_ message: String) {
        mockCalled = true
        infoCallsCount += 1
        infoReceivedArguments = message
        infoReceivedInvocations.append(message)
        infoClosure?(message)
    }

    // MARK: - error

    /// Number of times the function was called.
    @Atomic public private(set) var errorCallsCount = 0
    /// `true` if the function was ever called.
    public var errorCalled: Bool {
        errorCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var errorReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var errorReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var errorClosure: ((String) -> Void)?

    /// Mocked function for `error(_ message: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func error(_ message: String) {
        mockCalled = true
        errorCallsCount += 1
        errorReceivedArguments = message
        errorReceivedInvocations.append(message)
        errorClosure?(message)
    }
}

/**
 Class to easily create a mocked version of the `ProfileStore` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class ProfileStoreMock: ProfileStore, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        getProfileIdCallsCount = 0
        getProfileIdReceivedArguments = nil
        getProfileIdReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        deleteProfileIdCallsCount = 0
        deleteProfileIdReceivedArguments = nil
        deleteProfileIdReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - getProfileId

    /// Number of times the function was called.
    @Atomic public private(set) var getProfileIdCallsCount = 0
    /// `true` if the function was ever called.
    public var getProfileIdCalled: Bool {
        getProfileIdCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var getProfileIdReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var getProfileIdReceivedInvocations: [String] = []
    /// Value to return from the mocked function.
    public var getProfileIdReturnValue: String?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getProfileIdReturnValue`
     */
    public var getProfileIdClosure: ((String) -> String?)?

    /// Mocked function for `getProfileId(siteId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func getProfileId(siteId: String) -> String? {
        mockCalled = true
        getProfileIdCallsCount += 1
        getProfileIdReceivedArguments = siteId
        getProfileIdReceivedInvocations.append(siteId)
        return getProfileIdClosure.map { $0(siteId) } ?? getProfileIdReturnValue
    }

    // MARK: - deleteProfileId

    /// Number of times the function was called.
    @Atomic public private(set) var deleteProfileIdCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteProfileIdCalled: Bool {
        deleteProfileIdCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var deleteProfileIdReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var deleteProfileIdReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var deleteProfileIdClosure: ((String) -> Void)?

    /// Mocked function for `deleteProfileId(siteId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func deleteProfileId(siteId: String) {
        mockCalled = true
        deleteProfileIdCallsCount += 1
        deleteProfileIdReceivedArguments = siteId
        deleteProfileIdReceivedInvocations.append(siteId)
        deleteProfileIdClosure?(siteId)
    }
}

/**
 Class to easily create a mocked version of the `Queue` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class QueueMock: Queue, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        getAllStoredTasksCallsCount = 0
        getAllStoredTasksReceivedArguments = nil
        getAllStoredTasksReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        getTaskDetailCallsCount = 0
        getTaskDetailReceivedArguments = nil
        getTaskDetailReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        deleteProcessedTaskCallsCount = 0
        deleteProcessedTaskReceivedArguments = nil
        deleteProcessedTaskReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - getAllStoredTasks

    /// Number of times the function was called.
    @Atomic public private(set) var getAllStoredTasksCallsCount = 0
    /// `true` if the function was ever called.
    public var getAllStoredTasksCalled: Bool {
        getAllStoredTasksCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var getAllStoredTasksReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var getAllStoredTasksReceivedInvocations: [String] = []
    /// Value to return from the mocked function.
    public var getAllStoredTasksReturnValue: [QueueTaskMetadata]!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getAllStoredTasksReturnValue`
     */
    public var getAllStoredTasksClosure: ((String) -> [QueueTaskMetadata])?

    /// Mocked function for `getAllStoredTasks(siteId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func getAllStoredTasks(siteId: String) -> [QueueTaskMetadata] {
        mockCalled = true
        getAllStoredTasksCallsCount += 1
        getAllStoredTasksReceivedArguments = siteId
        getAllStoredTasksReceivedInvocations.append(siteId)
        return getAllStoredTasksClosure.map { $0(siteId) } ?? getAllStoredTasksReturnValue
    }

    // MARK: - getTaskDetail

    /// Number of times the function was called.
    @Atomic public private(set) var getTaskDetailCallsCount = 0
    /// `true` if the function was ever called.
    public var getTaskDetailCalled: Bool {
        getTaskDetailCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var getTaskDetailReceivedArguments: (task: QueueTaskMetadata, siteId: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var getTaskDetailReceivedInvocations: [(task: QueueTaskMetadata, siteId: String)] = []
    /// Value to return from the mocked function.
    public var getTaskDetailReturnValue: TaskDetail?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getTaskDetailReturnValue`
     */
    public var getTaskDetailClosure: ((QueueTaskMetadata, String) -> TaskDetail?)?

    /// Mocked function for `getTaskDetail(_ task: QueueTaskMetadata, siteId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func getTaskDetail(_ task: QueueTaskMetadata, siteId: String) -> TaskDetail? {
        mockCalled = true
        getTaskDetailCallsCount += 1
        getTaskDetailReceivedArguments = (task: task, siteId: siteId)
        getTaskDetailReceivedInvocations.append((task: task, siteId: siteId))
        return getTaskDetailClosure.map { $0(task, siteId) } ?? getTaskDetailReturnValue
    }

    // MARK: - deleteProcessedTask

    /// Number of times the function was called.
    @Atomic public private(set) var deleteProcessedTaskCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteProcessedTaskCalled: Bool {
        deleteProcessedTaskCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var deleteProcessedTaskReceivedArguments: (task: QueueTaskMetadata, siteId: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var deleteProcessedTaskReceivedInvocations: [(task: QueueTaskMetadata, siteId: String)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var deleteProcessedTaskClosure: ((QueueTaskMetadata, String) -> Void)?

    /// Mocked function for `deleteProcessedTask(_ task: QueueTaskMetadata, siteId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func deleteProcessedTask(_ task: QueueTaskMetadata, siteId: String) {
        mockCalled = true
        deleteProcessedTaskCallsCount += 1
        deleteProcessedTaskReceivedArguments = (task: task, siteId: siteId)
        deleteProcessedTaskReceivedInvocations.append((task: task, siteId: siteId))
        deleteProcessedTaskClosure?(task, siteId)
    }
}

/**
 Class to easily create a mocked version of the `QueueStorage` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class QueueStorageMock: QueueStorage, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        getInventoryCallsCount = 0
        getInventoryReceivedArguments = nil
        getInventoryReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        getCallsCount = 0
        getReceivedArguments = nil
        getReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        deleteCallsCount = 0
        deleteReceivedArguments = nil
        deleteReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - getInventory

    /// Number of times the function was called.
    @Atomic public private(set) var getInventoryCallsCount = 0
    /// `true` if the function was ever called.
    public var getInventoryCalled: Bool {
        getInventoryCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var getInventoryReceivedArguments: String?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var getInventoryReceivedInvocations: [String] = []
    /// Value to return from the mocked function.
    public var getInventoryReturnValue: [QueueTaskMetadata]!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getInventoryReturnValue`
     */
    public var getInventoryClosure: ((String) -> [QueueTaskMetadata])?

    /// Mocked function for `getInventory(siteId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func getInventory(siteId: String) -> [QueueTaskMetadata] {
        mockCalled = true
        getInventoryCallsCount += 1
        getInventoryReceivedArguments = siteId
        getInventoryReceivedInvocations.append(siteId)
        return getInventoryClosure.map { $0(siteId) } ?? getInventoryReturnValue
    }

    // MARK: - get

    /// Number of times the function was called.
    @Atomic public private(set) var getCallsCount = 0
    /// `true` if the function was ever called.
    public var getCalled: Bool {
        getCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var getReceivedArguments: (storageId: String, siteId: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var getReceivedInvocations: [(storageId: String, siteId: String)] = []
    /// Value to return from the mocked function.
    public var getReturnValue: QueueTask?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getReturnValue`
     */
    public var getClosure: ((String, String) -> QueueTask?)?

    /// Mocked function for `get(storageId: String, siteId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func get(storageId: String, siteId: String) -> QueueTask? {
        mockCalled = true
        getCallsCount += 1
        getReceivedArguments = (storageId: storageId, siteId: siteId)
        getReceivedInvocations.append((storageId: storageId, siteId: siteId))
        return getClosure.map { $0(storageId, siteId) } ?? getReturnValue
    }

    // MARK: - delete

    /// Number of times the function was called.
    @Atomic public private(set) var deleteCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteCalled: Bool {
        deleteCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var deleteReceivedArguments: (storageId: String, siteId: String)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var deleteReceivedInvocations: [(storageId: String, siteId: String)] = []
    /// Value to return from the mocked function.
    public var deleteReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `deleteReturnValue`
     */
    public var deleteClosure: ((String, String) -> Bool)?

    /// Mocked function for `delete(storageId: String, siteId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func delete(storageId: String, siteId: String) -> Bool {
        mockCalled = true
        deleteCallsCount += 1
        deleteReceivedArguments = (storageId: storageId, siteId: siteId)
        deleteReceivedInvocations.append((storageId: storageId, siteId: siteId))
        return deleteClosure.map { $0(storageId, siteId) } ?? deleteReturnValue
    }
}

/**
 Class to easily create a mocked version of the `SdkClient` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class SdkClientMock: SdkClient, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingSource: String!
    /// `true` if the getter or setter of property is called at least once.
    public var sourceCalled: Bool {
        sourceGetCalled || sourceSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var sourceGetCalled: Bool {
        sourceGetCallsCount > 0
    }

    public var sourceGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var sourceSetCalled: Bool {
        sourceSetCallsCount > 0
    }

    public var sourceSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var source: String {
        get {
            mockCalled = true
            sourceGetCallsCount += 1
            return underlyingSource
        }
        set(value) {
            mockCalled = true
            sourceSetCallsCount += 1
            underlyingSource = value
        }
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingSdkVersion: String!
    /// `true` if the getter or setter of property is called at least once.
    public var sdkVersionCalled: Bool {
        sdkVersionGetCalled || sdkVersionSetCalled
    }

    /// `true` if the getter called on the property at least once.
    public var sdkVersionGetCalled: Bool {
        sdkVersionGetCallsCount > 0
    }

    public var sdkVersionGetCallsCount = 0
    /// `true` if the setter called on the property at least once.
    public var sdkVersionSetCalled: Bool {
        sdkVersionSetCallsCount > 0
    }

    public var sdkVersionSetCallsCount = 0
    /// The mocked property with a getter and setter.
    public var sdkVersion: String {
        get {
            mockCalled = true
            sdkVersionGetCallsCount += 1
            return underlyingSdkVersion
        }
        set(value) {
            mockCalled = true
            sdkVersionSetCallsCount += 1
            underlyingSdkVersion = value
        }
    }

    public func resetMock() {
        sourceGetCallsCount = 0
        sourceSetCallsCount = 0
        sdkVersionGetCallsCount = 0
        sdkVersionSetCallsCount = 0
    }
}

/**
 Class to easily create a mocked version of the `SimpleTimer` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
class SimpleTimerMock: SimpleTimer, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    var mockCalled: Bool = false //

    init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        scheduleAndCancelPreviousCallsCount = 0
        scheduleAndCancelPreviousReceivedArguments = nil
        scheduleAndCancelPreviousReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        scheduleIfNotAlreadyCallsCount = 0
        scheduleIfNotAlreadyReceivedArguments = nil
        scheduleIfNotAlreadyReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        cancelCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - scheduleAndCancelPrevious

    /// Number of times the function was called.
    @Atomic private(set) var scheduleAndCancelPreviousCallsCount = 0
    /// `true` if the function was ever called.
    var scheduleAndCancelPreviousCalled: Bool {
        scheduleAndCancelPreviousCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var scheduleAndCancelPreviousReceivedArguments: (seconds: Seconds, block: () -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var scheduleAndCancelPreviousReceivedInvocations: [(seconds: Seconds, block: () -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var scheduleAndCancelPreviousClosure: ((Seconds, @escaping () -> Void) -> Void)?

    /// Mocked function for `scheduleAndCancelPrevious(seconds: Seconds, block: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    func scheduleAndCancelPrevious(seconds: Seconds, block: @escaping () -> Void) {
        mockCalled = true
        scheduleAndCancelPreviousCallsCount += 1
        scheduleAndCancelPreviousReceivedArguments = (seconds: seconds, block: block)
        scheduleAndCancelPreviousReceivedInvocations.append((seconds: seconds, block: block))
        scheduleAndCancelPreviousClosure?(seconds, block)
    }

    // MARK: - scheduleIfNotAlready

    /// Number of times the function was called.
    @Atomic private(set) var scheduleIfNotAlreadyCallsCount = 0
    /// `true` if the function was ever called.
    var scheduleIfNotAlreadyCalled: Bool {
        scheduleIfNotAlreadyCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var scheduleIfNotAlreadyReceivedArguments: (seconds: Seconds, block: () -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var scheduleIfNotAlreadyReceivedInvocations: [(seconds: Seconds, block: () -> Void)] = []
    /// Value to return from the mocked function.
    var scheduleIfNotAlreadyReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `scheduleIfNotAlreadyReturnValue`
     */
    var scheduleIfNotAlreadyClosure: ((Seconds, @escaping () -> Void) -> Bool)?

    /// Mocked function for `scheduleIfNotAlready(seconds: Seconds, block: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    func scheduleIfNotAlready(seconds: Seconds, block: @escaping () -> Void) -> Bool {
        mockCalled = true
        scheduleIfNotAlreadyCallsCount += 1
        scheduleIfNotAlreadyReceivedArguments = (seconds: seconds, block: block)
        scheduleIfNotAlreadyReceivedInvocations.append((seconds: seconds, block: block))
        return scheduleIfNotAlreadyClosure.map { $0(seconds, block) } ?? scheduleIfNotAlreadyReturnValue
    }

    // MARK: - cancel

    /// Number of times the function was called.
    @Atomic private(set) var cancelCallsCount = 0
    /// `true` if the function was ever called.
    var cancelCalled: Bool {
        cancelCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var cancelClosure: (() -> Void)?

    /// Mocked function for `cancel()`. Your opportunity to return a mocked value and check result of mock in test code.
    func cancel() {
        mockCalled = true
        cancelCallsCount += 1
        cancelClosure?()
    }
}

/**
 Class to easily create a mocked version of the `SingleScheduleTimer` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
class SingleScheduleTimerMock: SingleScheduleTimer, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    var mockCalled: Bool = false //

    init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        scheduleIfNotAlreadyCallsCount = 0
        scheduleIfNotAlreadyReceivedArguments = nil
        scheduleIfNotAlreadyReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        cancelCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - scheduleIfNotAlready

    /// Number of times the function was called.
    @Atomic private(set) var scheduleIfNotAlreadyCallsCount = 0
    /// `true` if the function was ever called.
    var scheduleIfNotAlreadyCalled: Bool {
        scheduleIfNotAlreadyCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic private(set) var scheduleIfNotAlreadyReceivedArguments: (seconds: Seconds, block: () -> Void)?
    /// Arguments from *all* of the times that the function was called.
    @Atomic private(set) var scheduleIfNotAlreadyReceivedInvocations: [(seconds: Seconds, block: () -> Void)] = []
    /// Value to return from the mocked function.
    var scheduleIfNotAlreadyReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `scheduleIfNotAlreadyReturnValue`
     */
    var scheduleIfNotAlreadyClosure: ((Seconds, @escaping () -> Void) -> Bool)?

    /// Mocked function for `scheduleIfNotAlready(seconds: Seconds, block: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    func scheduleIfNotAlready(seconds: Seconds, block: @escaping () -> Void) -> Bool {
        mockCalled = true
        scheduleIfNotAlreadyCallsCount += 1
        scheduleIfNotAlreadyReceivedArguments = (seconds: seconds, block: block)
        scheduleIfNotAlreadyReceivedInvocations.append((seconds: seconds, block: block))
        return scheduleIfNotAlreadyClosure.map { $0(seconds, block) } ?? scheduleIfNotAlreadyReturnValue
    }

    // MARK: - cancel

    /// Number of times the function was called.
    @Atomic private(set) var cancelCallsCount = 0
    /// `true` if the function was ever called.
    var cancelCalled: Bool {
        cancelCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    var cancelClosure: (() -> Void)?

    /// Mocked function for `cancel()`. Your opportunity to return a mocked value and check result of mock in test code.
    func cancel() {
        mockCalled = true
        cancelCallsCount += 1
        cancelClosure?()
    }
}

/**
 Class to easily create a mocked version of the `UIKitWrapper` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
@available(iOSApplicationExtension, unavailable)
public class UIKitWrapperMock: UIKitWrapper, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        openCallsCount = 0
        openReceivedArguments = nil
        openReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
        continueNSUserActivityCallsCount = 0
        continueNSUserActivityReceivedArguments = nil
        continueNSUserActivityReceivedInvocations = []

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - open

    /// Number of times the function was called.
    @Atomic public private(set) var openCallsCount = 0
    /// `true` if the function was ever called.
    public var openCalled: Bool {
        openCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var openReceivedArguments: URL?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var openReceivedInvocations: [URL] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var openClosure: ((URL) -> Void)?

    /// Mocked function for `open(url: URL)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func open(url: URL) {
        mockCalled = true
        openCallsCount += 1
        openReceivedArguments = url
        openReceivedInvocations.append(url)
        openClosure?(url)
    }

    // MARK: - continueNSUserActivity

    /// Number of times the function was called.
    @Atomic public private(set) var continueNSUserActivityCallsCount = 0
    /// `true` if the function was ever called.
    public var continueNSUserActivityCalled: Bool {
        continueNSUserActivityCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    @Atomic public private(set) var continueNSUserActivityReceivedArguments: URL?
    /// Arguments from *all* of the times that the function was called.
    @Atomic public private(set) var continueNSUserActivityReceivedInvocations: [URL] = []
    /// Value to return from the mocked function.
    public var continueNSUserActivityReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `continueNSUserActivityReturnValue`
     */
    public var continueNSUserActivityClosure: ((URL) -> Bool)?

    /// Mocked function for `continueNSUserActivity(webpageURL: URL)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func continueNSUserActivity(webpageURL: URL) -> Bool {
        mockCalled = true
        continueNSUserActivityCallsCount += 1
        continueNSUserActivityReceivedArguments = webpageURL
        continueNSUserActivityReceivedInvocations.append(webpageURL)
        return continueNSUserActivityClosure.map { $0(webpageURL) } ?? continueNSUserActivityReturnValue
    }
}

/**
 Class to easily create a mocked version of the `UserAgentUtil` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class UserAgentUtilMock: UserAgentUtil, Mock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    public init() {
        Mocks.shared.add(mock: self)
    }

    public func resetMock() {
        getUserAgentHeaderValueCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
        getNSEUserAgentHeaderValueCallsCount = 0

        mockCalled = false // do last as resetting properties above can make this true
    }

    // MARK: - getUserAgentHeaderValue

    /// Number of times the function was called.
    @Atomic public private(set) var getUserAgentHeaderValueCallsCount = 0
    /// `true` if the function was ever called.
    public var getUserAgentHeaderValueCalled: Bool {
        getUserAgentHeaderValueCallsCount > 0
    }

    /// Value to return from the mocked function.
    public var getUserAgentHeaderValueReturnValue: String!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getUserAgentHeaderValueReturnValue`
     */
    public var getUserAgentHeaderValueClosure: (() -> String)?

    /// Mocked function for `getUserAgentHeaderValue()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func getUserAgentHeaderValue() -> String {
        mockCalled = true
        getUserAgentHeaderValueCallsCount += 1
        return getUserAgentHeaderValueClosure.map { $0() } ?? getUserAgentHeaderValueReturnValue
    }

    // MARK: - getNSEUserAgentHeaderValue

    /// Number of times the function was called.
    @Atomic public private(set) var getNSEUserAgentHeaderValueCallsCount = 0
    /// `true` if the function was ever called.
    public var getNSEUserAgentHeaderValueCalled: Bool {
        getNSEUserAgentHeaderValueCallsCount > 0
    }

    /// Value to return from the mocked function.
    public var getNSEUserAgentHeaderValueReturnValue: String!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getNSEUserAgentHeaderValueReturnValue`
     */
    public var getNSEUserAgentHeaderValueClosure: (() -> String)?

    /// Mocked function for `getNSEUserAgentHeaderValue()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func getNSEUserAgentHeaderValue() -> String {
        mockCalled = true
        getNSEUserAgentHeaderValueCallsCount += 1
        return getNSEUserAgentHeaderValueClosure.map { $0() } ?? getNSEUserAgentHeaderValueReturnValue
    }
}

// swiftlint:enable all
