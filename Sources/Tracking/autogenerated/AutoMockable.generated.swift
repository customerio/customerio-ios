// Generated using Sourcery 1.5.0 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT
// swiftlint:disable all

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

/**
 ######################################################
 Documentation
 ######################################################

 This automatically generated file you are viewing contains mock classes that you can use in your test suite.

 * How do you generate a new mock class?

 1. Mocks are generated from Swift protocols. So, you must make one.

 ```
 protocol FriendsRepository {
     func acceptFriendRequest<Attributes: Encodable>(attributes: Attributes, _ onComplete: @escaping () -> Void)
 }

 class AppFriendsRepository: FriendsRepository {
     ...
 }
 ```

 2. Have your new protocol extend `AutoMockable`:

 ```
 protocol FriendsRepository: AutoMockable {
     func acceptFriendRequest<Attributes: Encodable>(
         // sourcery:Type=Encodable
         attributes: Attributes,
         _ onComplete: @escaping () -> Void)
 }
 ```

 > Notice the use of `// sourcery:Type=Encodable` for the generic type parameter. Without this, the mock would
 fail to compile: `functionNameReceiveArguments = (Attributes)` because `Attributes` is unknown to this `var`.
 Instead, we give the parameter a different type to use for the mock. `Encodable` works in this case.
 It will require a cast in the test function code, however.

 3. Run the command `make generate` on your machine. The new mock should be added to this file.

 * How do you use the mocks in your test class?

 ```
 class ExampleViewModelTest: XCTestCase {
     var viewModel: ExampleViewModel!
     var exampleRepositoryMock: ExampleRepositoryMock!
     override func setUp() {
         exampleRepositoryMock = ExampleRepositoryMock()
         viewModel = AppExampleViewModel(exampleRepository: exampleRepositoryMock)
     }
 }
 ```

 Or, you may need to inject the mock in a different way using the DI.shared graph:

 ```
 class ExampleTest: XCTestCase {
     var exampleViewModelMock: ExampleViewModelMock!
     var example: Example!
     override func setUp() {
         exampleViewModelMock = ExampleViewModelMock()
         DI.shared.override(.exampleViewModel, value: exampleViewModelMock, forType: ExampleViewModel.self)
         example = Example()
     }
 }

 ```

 */

public class TrackingMocks {
    public static var shared = TrackingMocks()

    public var mocks: [TrackingMock] = []
    private init() {}

    func add(mock: TrackingMock) {
        mocks.append(mock)
    }

    func resetAll() {
        mocks.forEach {
            $0.reset()
        }
    }
}

public protocol TrackingMock {
    func reset()
}

/**
 Class to easily create a mocked version of the `CustomerIOInstance` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class CustomerIOInstanceMock: CustomerIOInstance, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public var siteId: String?

    public func reset() {
        mockCalled = false

        siteId = nil
        identifyCallsCount = 0
        identifyReceivedArguments = nil
        identifyReceivedInvocations = []
        trackCallsCount = 0
        trackReceivedArguments = nil
        trackReceivedInvocations = []
        clearIdentifyCallsCount = 0
    }

    // MARK: - identify<RequestBody: Encodable>

    /// Number of times the function was called.
    public private(set) var identifyCallsCount = 0
    /// `true` if the function was ever called.
    public var identifyCalled: Bool {
        identifyCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var identifyReceivedArguments: (identifier: String, body: AnyEncodable,
                                                        jsonEncoder: JSONEncoder?)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var identifyReceivedInvocations: [(identifier: String, body: AnyEncodable,
                                                           jsonEncoder: JSONEncoder?)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var identifyClosure: ((String, AnyEncodable, JSONEncoder?) -> Void)?

    /// Mocked function for `identify<RequestBody: Encodable>(identifier: String, body: RequestBody, jsonEncoder: JSONEncoder?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func identify<RequestBody: Encodable>(identifier: String, body: RequestBody, jsonEncoder: JSONEncoder?) {
        mockCalled = true
        identifyCallsCount += 1
        identifyReceivedArguments = (identifier: identifier, body: AnyEncodable(body), jsonEncoder: jsonEncoder)
        identifyReceivedInvocations.append((identifier: identifier, body: AnyEncodable(body), jsonEncoder: jsonEncoder))
        identifyClosure?(identifier, AnyEncodable(body), jsonEncoder)
    }

    // MARK: - track<RequestBody: Encodable>

    /// Number of times the function was called.
    public private(set) var trackCallsCount = 0
    /// `true` if the function was ever called.
    public var trackCalled: Bool {
        trackCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var trackReceivedArguments: (name: String, data: AnyEncodable, jsonEncoder: JSONEncoder?)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var trackReceivedInvocations: [(name: String, data: AnyEncodable, jsonEncoder: JSONEncoder?)] =
        []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var trackClosure: ((String, AnyEncodable, JSONEncoder?) -> Void)?

    /// Mocked function for `track<RequestBody: Encodable>(name: String, data: RequestBody?, jsonEncoder: JSONEncoder?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func track<RequestBody: Encodable>(name: String, data: RequestBody?, jsonEncoder: JSONEncoder?) {
        mockCalled = true
        trackCallsCount += 1
        trackReceivedArguments = (name: name, data: AnyEncodable(data), jsonEncoder: jsonEncoder)
        trackReceivedInvocations.append((name: name, data: AnyEncodable(data), jsonEncoder: jsonEncoder))
        trackClosure?(name, AnyEncodable(data), jsonEncoder)
    }

    // MARK: - clearIdentify

    /// Number of times the function was called.
    public private(set) var clearIdentifyCallsCount = 0
    /// `true` if the function was ever called.
    public var clearIdentifyCalled: Bool {
        clearIdentifyCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var clearIdentifyClosure: (() -> Void)?

    /// Mocked function for `clearIdentify()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func clearIdentify() {
        mockCalled = true
        clearIdentifyCallsCount += 1
        clearIdentifyClosure?()
    }
}

/**
 Class to easily create a mocked version of the `EventBus` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class EventBusMock: EventBus, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        postCallsCount = 0
        postReceivedArguments = nil
        postReceivedInvocations = []
        registerCallsCount = 0
        registerReceivedArguments = nil
        registerReceivedInvocations = []
        unregisterCallsCount = 0
        unregisterReceivedArguments = nil
        unregisterReceivedInvocations = []
    }

    // MARK: - post

    /// Number of times the function was called.
    public private(set) var postCallsCount = 0
    /// `true` if the function was ever called.
    public var postCalled: Bool {
        postCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var postReceivedArguments: (EventBusEvent)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var postReceivedInvocations: [EventBusEvent] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var postClosure: ((EventBusEvent) -> Void)?

    /// Mocked function for `post(_ event: EventBusEvent)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func post(_ event: EventBusEvent) {
        mockCalled = true
        postCallsCount += 1
        postReceivedArguments = event
        postReceivedInvocations.append(event)
        postClosure?(event)
    }

    // MARK: - register

    /// Number of times the function was called.
    public private(set) var registerCallsCount = 0
    /// `true` if the function was ever called.
    public var registerCalled: Bool {
        registerCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var registerReceivedArguments: (event: EventBusEvent, listener: EventBusEventListener)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var registerReceivedInvocations: [(event: EventBusEvent, listener: EventBusEventListener)] = []
    /// Value to return from the mocked function.
    public var registerReturnValue: EventBusListenerReference!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `registerReturnValue`
     */
    public var registerClosure: ((EventBusEvent, EventBusEventListener) -> EventBusListenerReference)?

    /// Mocked function for `register(event: EventBusEvent, listener: @escaping EventBusEventListener)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func register(event: EventBusEvent, listener: @escaping EventBusEventListener) -> EventBusListenerReference {
        mockCalled = true
        registerCallsCount += 1
        registerReceivedArguments = (event: event, listener: listener)
        registerReceivedInvocations.append((event: event, listener: listener))
        return registerClosure.map { $0(event, listener) } ?? registerReturnValue
    }

    // MARK: - unregister

    /// Number of times the function was called.
    public private(set) var unregisterCallsCount = 0
    /// `true` if the function was ever called.
    public var unregisterCalled: Bool {
        unregisterCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var unregisterReceivedArguments: (EventBusListenerReference?)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var unregisterReceivedInvocations: [EventBusListenerReference?] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var unregisterClosure: ((EventBusListenerReference?) -> Void)?

    /// Mocked function for `unregister(_ listener: EventBusListenerReference?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func unregister(_ listener: EventBusListenerReference?) {
        mockCalled = true
        unregisterCallsCount += 1
        unregisterReceivedArguments = listener
        unregisterReceivedInvocations.append(listener)
        unregisterClosure?(listener)
    }
}

/**
 Class to easily create a mocked version of the `FileStorage` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class FileStorageMock: FileStorage, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        saveCallsCount = 0
        saveReceivedArguments = nil
        saveReceivedInvocations = []
        getCallsCount = 0
        getReceivedArguments = nil
        getReceivedInvocations = []
        deleteCallsCount = 0
        deleteReceivedArguments = nil
        deleteReceivedInvocations = []
    }

    // MARK: - save

    /// Number of times the function was called.
    public private(set) var saveCallsCount = 0
    /// `true` if the function was ever called.
    public var saveCalled: Bool {
        saveCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var saveReceivedArguments: (type: FileType, contents: Data, fileId: String?)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var saveReceivedInvocations: [(type: FileType, contents: Data, fileId: String?)] = []
    /// Value to return from the mocked function.
    public var saveReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `saveReturnValue`
     */
    public var saveClosure: ((FileType, Data, String?) -> Bool)?

    /// Mocked function for `save(type: FileType, contents: Data, fileId: String?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func save(type: FileType, contents: Data, fileId: String?) -> Bool {
        mockCalled = true
        saveCallsCount += 1
        saveReceivedArguments = (type: type, contents: contents, fileId: fileId)
        saveReceivedInvocations.append((type: type, contents: contents, fileId: fileId))
        return saveClosure.map { $0(type, contents, fileId) } ?? saveReturnValue
    }

    // MARK: - get

    /// Number of times the function was called.
    public private(set) var getCallsCount = 0
    /// `true` if the function was ever called.
    public var getCalled: Bool {
        getCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var getReceivedArguments: (type: FileType, fileId: String?)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var getReceivedInvocations: [(type: FileType, fileId: String?)] = []
    /// Value to return from the mocked function.
    public var getReturnValue: Data?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getReturnValue`
     */
    public var getClosure: ((FileType, String?) -> Data?)?

    /// Mocked function for `get(type: FileType, fileId: String?)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func get(type: FileType, fileId: String?) -> Data? {
        mockCalled = true
        getCallsCount += 1
        getReceivedArguments = (type: type, fileId: fileId)
        getReceivedInvocations.append((type: type, fileId: fileId))
        return getClosure.map { $0(type, fileId) } ?? getReturnValue
    }

    // MARK: - delete

    /// Number of times the function was called.
    public private(set) var deleteCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteCalled: Bool {
        deleteCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var deleteReceivedArguments: (type: FileType, fileId: String)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var deleteReceivedInvocations: [(type: FileType, fileId: String)] = []
    /// Value to return from the mocked function.
    public var deleteReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `deleteReturnValue`
     */
    public var deleteClosure: ((FileType, String) -> Bool)?

    /// Mocked function for `delete(type: FileType, fileId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func delete(type: FileType, fileId: String) -> Bool {
        mockCalled = true
        deleteCallsCount += 1
        deleteReceivedArguments = (type: type, fileId: fileId)
        deleteReceivedInvocations.append((type: type, fileId: fileId))
        return deleteClosure.map { $0(type, fileId) } ?? deleteReturnValue
    }
}

/**
 Class to easily create a mocked version of the `HttpClient` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class HttpClientMock: HttpClient, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        requestCallsCount = 0
        requestReceivedArguments = nil
        requestReceivedInvocations = []
        downloadFileCallsCount = 0
        downloadFileReceivedArguments = nil
        downloadFileReceivedInvocations = []
        cancelCallsCount = 0
        cancelReceivedArguments = nil
        cancelReceivedInvocations = []
    }

    // MARK: - request

    /// Number of times the function was called.
    public private(set) var requestCallsCount = 0
    /// `true` if the function was ever called.
    public var requestCalled: Bool {
        requestCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var requestReceivedArguments: (params: HttpRequestParams,
                                                       onComplete: (Result<Data, HttpRequestError>) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var requestReceivedInvocations: [(params: HttpRequestParams,
                                                          onComplete: (Result<Data, HttpRequestError>) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var requestClosure: ((HttpRequestParams, (Result<Data, HttpRequestError>) -> Void) -> Void)?

    /// Mocked function for `request(_ params: HttpRequestParams, onComplete: @escaping (Result<Data, HttpRequestError>) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func request(_ params: HttpRequestParams, onComplete: @escaping (Result<Data, HttpRequestError>) -> Void) {
        mockCalled = true
        requestCallsCount += 1
        requestReceivedArguments = (params: params, onComplete: onComplete)
        requestReceivedInvocations.append((params: params, onComplete: onComplete))
        requestClosure?(params, onComplete)
    }

    // MARK: - downloadFile

    /// Number of times the function was called.
    public private(set) var downloadFileCallsCount = 0
    /// `true` if the function was ever called.
    public var downloadFileCalled: Bool {
        downloadFileCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var downloadFileReceivedArguments: (url: URL, fileType: DownloadFileType,
                                                            onComplete: (URL?) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var downloadFileReceivedInvocations: [(url: URL, fileType: DownloadFileType,
                                                               onComplete: (URL?) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var downloadFileClosure: ((URL, DownloadFileType, (URL?) -> Void) -> Void)?

    /// Mocked function for `downloadFile(url: URL, fileType: DownloadFileType, onComplete: @escaping (URL?) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func downloadFile(url: URL, fileType: DownloadFileType, onComplete: @escaping (URL?) -> Void) {
        mockCalled = true
        downloadFileCallsCount += 1
        downloadFileReceivedArguments = (url: url, fileType: fileType, onComplete: onComplete)
        downloadFileReceivedInvocations.append((url: url, fileType: fileType, onComplete: onComplete))
        downloadFileClosure?(url, fileType, onComplete)
    }

    // MARK: - cancel

    /// Number of times the function was called.
    public private(set) var cancelCallsCount = 0
    /// `true` if the function was ever called.
    public var cancelCalled: Bool {
        cancelCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var cancelReceivedArguments: (Bool)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var cancelReceivedInvocations: [Bool] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var cancelClosure: ((Bool) -> Void)?

    /// Mocked function for `cancel(finishTasks: Bool)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func cancel(finishTasks: Bool) {
        mockCalled = true
        cancelCallsCount += 1
        cancelReceivedArguments = finishTasks
        cancelReceivedInvocations.append(finishTasks)
        cancelClosure?(finishTasks)
    }
}

/**
 Class to easily create a mocked version of the `HttpRequestRunner` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
internal class HttpRequestRunnerMock: HttpRequestRunner, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    internal var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        requestCallsCount = 0
        requestReceivedArguments = nil
        requestReceivedInvocations = []
        downloadFileCallsCount = 0
        downloadFileReceivedArguments = nil
        downloadFileReceivedInvocations = []
    }

    // MARK: - request

    /// Number of times the function was called.
    internal private(set) var requestCallsCount = 0
    /// `true` if the function was ever called.
    internal var requestCalled: Bool {
        requestCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    internal private(set) var requestReceivedArguments: (params: HttpRequestParams, httpBaseUrls: HttpBaseUrls,
                                                         session: URLSession,
                                                         onComplete: (Data?, HTTPURLResponse?, Error?) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    internal private(set) var requestReceivedInvocations: [(params: HttpRequestParams, httpBaseUrls: HttpBaseUrls,
                                                            session: URLSession,
                                                            onComplete: (Data?, HTTPURLResponse?, Error?) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    internal var requestClosure: ((HttpRequestParams, HttpBaseUrls, URLSession,
                                   (Data?, HTTPURLResponse?, Error?) -> Void) -> Void)?

    /// Mocked function for `request(_ params: HttpRequestParams, httpBaseUrls: HttpBaseUrls, session: URLSession, onComplete: @escaping (Data?, HTTPURLResponse?, Error?) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func request(
        _ params: HttpRequestParams,
        httpBaseUrls: HttpBaseUrls,
        session: URLSession,
        onComplete: @escaping (Data?, HTTPURLResponse?, Error?) -> Void
    ) {
        mockCalled = true
        requestCallsCount += 1
        requestReceivedArguments = (params: params, httpBaseUrls: httpBaseUrls, session: session,
                                    onComplete: onComplete)
        requestReceivedInvocations
            .append((params: params, httpBaseUrls: httpBaseUrls, session: session, onComplete: onComplete))
        requestClosure?(params, httpBaseUrls, session, onComplete)
    }

    // MARK: - downloadFile

    /// Number of times the function was called.
    internal private(set) var downloadFileCallsCount = 0
    /// `true` if the function was ever called.
    internal var downloadFileCalled: Bool {
        downloadFileCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    internal private(set) var downloadFileReceivedArguments: (url: URL, fileType: DownloadFileType, session: URLSession,
                                                              onComplete: (URL?) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    internal private(set) var downloadFileReceivedInvocations: [(url: URL, fileType: DownloadFileType,
                                                                 session: URLSession, onComplete: (URL?) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    internal var downloadFileClosure: ((URL, DownloadFileType, URLSession, (URL?) -> Void) -> Void)?

    /// Mocked function for `downloadFile(url: URL, fileType: DownloadFileType, session: URLSession, onComplete: @escaping (URL?) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func downloadFile(
        url: URL,
        fileType: DownloadFileType,
        session: URLSession,
        onComplete: @escaping (URL?) -> Void
    ) {
        mockCalled = true
        downloadFileCallsCount += 1
        downloadFileReceivedArguments = (url: url, fileType: fileType, session: session, onComplete: onComplete)
        downloadFileReceivedInvocations.append((url: url, fileType: fileType, session: session, onComplete: onComplete))
        downloadFileClosure?(url, fileType, session, onComplete)
    }
}

/**
 Class to easily create a mocked version of the `KeyValueStorage` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class KeyValueStorageMock: KeyValueStorage, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        integerCallsCount = 0
        integerReceivedArguments = nil
        integerReceivedInvocations = []
        setIntCallsCount = 0
        setIntReceivedArguments = nil
        setIntReceivedInvocations = []
        doubleCallsCount = 0
        doubleReceivedArguments = nil
        doubleReceivedInvocations = []
        setDoubleCallsCount = 0
        setDoubleReceivedArguments = nil
        setDoubleReceivedInvocations = []
        stringCallsCount = 0
        stringReceivedArguments = nil
        stringReceivedInvocations = []
        setStringCallsCount = 0
        setStringReceivedArguments = nil
        setStringReceivedInvocations = []
        dateCallsCount = 0
        dateReceivedArguments = nil
        dateReceivedInvocations = []
        setDateCallsCount = 0
        setDateReceivedArguments = nil
        setDateReceivedInvocations = []
        deleteAllCallsCount = 0
    }

    // MARK: - integer

    /// Number of times the function was called.
    public private(set) var integerCallsCount = 0
    /// `true` if the function was ever called.
    public var integerCalled: Bool {
        integerCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var integerReceivedArguments: (KeyValueStorageKey)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var integerReceivedInvocations: [KeyValueStorageKey] = []
    /// Value to return from the mocked function.
    public var integerReturnValue: Int?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `integerReturnValue`
     */
    public var integerClosure: ((KeyValueStorageKey) -> Int?)?

    /// Mocked function for `integer(_ key: KeyValueStorageKey)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func integer(_ key: KeyValueStorageKey) -> Int? {
        mockCalled = true
        integerCallsCount += 1
        integerReceivedArguments = key
        integerReceivedInvocations.append(key)
        return integerClosure.map { $0(key) } ?? integerReturnValue
    }

    // MARK: - setInt

    /// Number of times the function was called.
    public private(set) var setIntCallsCount = 0
    /// `true` if the function was ever called.
    public var setIntCalled: Bool {
        setIntCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var setIntReceivedArguments: (value: Int?, key: KeyValueStorageKey)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var setIntReceivedInvocations: [(value: Int?, key: KeyValueStorageKey)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var setIntClosure: ((Int?, KeyValueStorageKey) -> Void)?

    /// Mocked function for `setInt(_ value: Int?, forKey key: KeyValueStorageKey)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func setInt(_ value: Int?, forKey key: KeyValueStorageKey) {
        mockCalled = true
        setIntCallsCount += 1
        setIntReceivedArguments = (value: value, key: key)
        setIntReceivedInvocations.append((value: value, key: key))
        setIntClosure?(value, key)
    }

    // MARK: - double

    /// Number of times the function was called.
    public private(set) var doubleCallsCount = 0
    /// `true` if the function was ever called.
    public var doubleCalled: Bool {
        doubleCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var doubleReceivedArguments: (KeyValueStorageKey)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var doubleReceivedInvocations: [KeyValueStorageKey] = []
    /// Value to return from the mocked function.
    public var doubleReturnValue: Double?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `doubleReturnValue`
     */
    public var doubleClosure: ((KeyValueStorageKey) -> Double?)?

    /// Mocked function for `double(_ key: KeyValueStorageKey)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func double(_ key: KeyValueStorageKey) -> Double? {
        mockCalled = true
        doubleCallsCount += 1
        doubleReceivedArguments = key
        doubleReceivedInvocations.append(key)
        return doubleClosure.map { $0(key) } ?? doubleReturnValue
    }

    // MARK: - setDouble

    /// Number of times the function was called.
    public private(set) var setDoubleCallsCount = 0
    /// `true` if the function was ever called.
    public var setDoubleCalled: Bool {
        setDoubleCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var setDoubleReceivedArguments: (value: Double?, key: KeyValueStorageKey)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var setDoubleReceivedInvocations: [(value: Double?, key: KeyValueStorageKey)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var setDoubleClosure: ((Double?, KeyValueStorageKey) -> Void)?

    /// Mocked function for `setDouble(_ value: Double?, forKey key: KeyValueStorageKey)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func setDouble(_ value: Double?, forKey key: KeyValueStorageKey) {
        mockCalled = true
        setDoubleCallsCount += 1
        setDoubleReceivedArguments = (value: value, key: key)
        setDoubleReceivedInvocations.append((value: value, key: key))
        setDoubleClosure?(value, key)
    }

    // MARK: - string

    /// Number of times the function was called.
    public private(set) var stringCallsCount = 0
    /// `true` if the function was ever called.
    public var stringCalled: Bool {
        stringCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var stringReceivedArguments: (KeyValueStorageKey)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var stringReceivedInvocations: [KeyValueStorageKey] = []
    /// Value to return from the mocked function.
    public var stringReturnValue: String?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `stringReturnValue`
     */
    public var stringClosure: ((KeyValueStorageKey) -> String?)?

    /// Mocked function for `string(_ key: KeyValueStorageKey)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func string(_ key: KeyValueStorageKey) -> String? {
        mockCalled = true
        stringCallsCount += 1
        stringReceivedArguments = key
        stringReceivedInvocations.append(key)
        return stringClosure.map { $0(key) } ?? stringReturnValue
    }

    // MARK: - setString

    /// Number of times the function was called.
    public private(set) var setStringCallsCount = 0
    /// `true` if the function was ever called.
    public var setStringCalled: Bool {
        setStringCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var setStringReceivedArguments: (value: String?, key: KeyValueStorageKey)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var setStringReceivedInvocations: [(value: String?, key: KeyValueStorageKey)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var setStringClosure: ((String?, KeyValueStorageKey) -> Void)?

    /// Mocked function for `setString(_ value: String?, forKey key: KeyValueStorageKey)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func setString(_ value: String?, forKey key: KeyValueStorageKey) {
        mockCalled = true
        setStringCallsCount += 1
        setStringReceivedArguments = (value: value, key: key)
        setStringReceivedInvocations.append((value: value, key: key))
        setStringClosure?(value, key)
    }

    // MARK: - date

    /// Number of times the function was called.
    public private(set) var dateCallsCount = 0
    /// `true` if the function was ever called.
    public var dateCalled: Bool {
        dateCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var dateReceivedArguments: (KeyValueStorageKey)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var dateReceivedInvocations: [KeyValueStorageKey] = []
    /// Value to return from the mocked function.
    public var dateReturnValue: Date?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `dateReturnValue`
     */
    public var dateClosure: ((KeyValueStorageKey) -> Date?)?

    /// Mocked function for `date(_ key: KeyValueStorageKey)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func date(_ key: KeyValueStorageKey) -> Date? {
        mockCalled = true
        dateCallsCount += 1
        dateReceivedArguments = key
        dateReceivedInvocations.append(key)
        return dateClosure.map { $0(key) } ?? dateReturnValue
    }

    // MARK: - setDate

    /// Number of times the function was called.
    public private(set) var setDateCallsCount = 0
    /// `true` if the function was ever called.
    public var setDateCalled: Bool {
        setDateCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var setDateReceivedArguments: (value: Date?, key: KeyValueStorageKey)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var setDateReceivedInvocations: [(value: Date?, key: KeyValueStorageKey)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var setDateClosure: ((Date?, KeyValueStorageKey) -> Void)?

    /// Mocked function for `setDate(_ value: Date?, forKey key: KeyValueStorageKey)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func setDate(_ value: Date?, forKey key: KeyValueStorageKey) {
        mockCalled = true
        setDateCallsCount += 1
        setDateReceivedArguments = (value: value, key: key)
        setDateReceivedInvocations.append((value: value, key: key))
        setDateClosure?(value, key)
    }

    // MARK: - deleteAll

    /// Number of times the function was called.
    public private(set) var deleteAllCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteAllCalled: Bool {
        deleteAllCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var deleteAllClosure: (() -> Void)?

    /// Mocked function for `deleteAll()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func deleteAll() {
        mockCalled = true
        deleteAllCallsCount += 1
        deleteAllClosure?()
    }
}

/**
 Class to easily create a mocked version of the `Logger` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class LoggerMock: Logger, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        verboseCallsCount = 0
        verboseReceivedArguments = nil
        verboseReceivedInvocations = []
        debugCallsCount = 0
        debugReceivedArguments = nil
        debugReceivedInvocations = []
        infoCallsCount = 0
        infoReceivedArguments = nil
        infoReceivedInvocations = []
        warningCallsCount = 0
        warningReceivedArguments = nil
        warningReceivedInvocations = []
        errorCallsCount = 0
        errorReceivedArguments = nil
        errorReceivedInvocations = []
    }

    // MARK: - verbose

    /// Number of times the function was called.
    public private(set) var verboseCallsCount = 0
    /// `true` if the function was ever called.
    public var verboseCalled: Bool {
        verboseCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var verboseReceivedArguments: (String)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var verboseReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var verboseClosure: ((String) -> Void)?

    /// Mocked function for `verbose(_ message: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func verbose(_ message: String) {
        mockCalled = true
        verboseCallsCount += 1
        verboseReceivedArguments = message
        verboseReceivedInvocations.append(message)
        verboseClosure?(message)
    }

    // MARK: - debug

    /// Number of times the function was called.
    public private(set) var debugCallsCount = 0
    /// `true` if the function was ever called.
    public var debugCalled: Bool {
        debugCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var debugReceivedArguments: (String)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var debugReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var debugClosure: ((String) -> Void)?

    /// Mocked function for `debug(_ message: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func debug(_ message: String) {
        mockCalled = true
        debugCallsCount += 1
        debugReceivedArguments = message
        debugReceivedInvocations.append(message)
        debugClosure?(message)
    }

    // MARK: - info

    /// Number of times the function was called.
    public private(set) var infoCallsCount = 0
    /// `true` if the function was ever called.
    public var infoCalled: Bool {
        infoCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var infoReceivedArguments: (String)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var infoReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var infoClosure: ((String) -> Void)?

    /// Mocked function for `info(_ message: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func info(_ message: String) {
        mockCalled = true
        infoCallsCount += 1
        infoReceivedArguments = message
        infoReceivedInvocations.append(message)
        infoClosure?(message)
    }

    // MARK: - warning

    /// Number of times the function was called.
    public private(set) var warningCallsCount = 0
    /// `true` if the function was ever called.
    public var warningCalled: Bool {
        warningCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var warningReceivedArguments: (String)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var warningReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var warningClosure: ((String) -> Void)?

    /// Mocked function for `warning(_ message: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func warning(_ message: String) {
        mockCalled = true
        warningCallsCount += 1
        warningReceivedArguments = message
        warningReceivedInvocations.append(message)
        warningClosure?(message)
    }

    // MARK: - error

    /// Number of times the function was called.
    public private(set) var errorCallsCount = 0
    /// `true` if the function was ever called.
    public var errorCalled: Bool {
        errorCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var errorReceivedArguments: (String)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var errorReceivedInvocations: [String] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var errorClosure: ((String) -> Void)?

    /// Mocked function for `error(_ message: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func error(_ message: String) {
        mockCalled = true
        errorCallsCount += 1
        errorReceivedArguments = message
        errorReceivedInvocations.append(message)
        errorClosure?(message)
    }
}

/**
 Class to easily create a mocked version of the `ProfileStore` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class ProfileStoreMock: ProfileStore, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public var identifier: String?

    public func reset() {
        mockCalled = false

        identifier = nil
    }
}

/**
 Class to easily create a mocked version of the `Queue` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class QueueMock: Queue, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        addTaskCallsCount = 0
        addTaskReceivedArguments = nil
        addTaskReceivedInvocations = []
        runCallsCount = 0
        runReceivedArguments = nil
        runReceivedInvocations = []
    }

    // MARK: - addTask<TaskData: Codable>

    /// Number of times the function was called.
    public private(set) var addTaskCallsCount = 0
    /// `true` if the function was ever called.
    public var addTaskCalled: Bool {
        addTaskCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var addTaskReceivedArguments: (type: QueueTaskType, data: AnyEncodable)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var addTaskReceivedInvocations: [(type: QueueTaskType, data: AnyEncodable)] = []
    /// Value to return from the mocked function.
    public var addTaskReturnValue: (success: Bool, queueStatus: QueueStatus)!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `addTaskReturnValue`
     */
    public var addTaskClosure: ((QueueTaskType, AnyEncodable) -> (success: Bool, queueStatus: QueueStatus))?

    /// Mocked function for `addTask<TaskData: Codable>(type: QueueTaskType, data: TaskData)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func addTask<TaskData: Codable>(type: QueueTaskType,
                                           data: TaskData) -> (success: Bool, queueStatus: QueueStatus)
    {
        mockCalled = true
        addTaskCallsCount += 1
        addTaskReceivedArguments = (type: type, data: AnyEncodable(data))
        addTaskReceivedInvocations.append((type: type, data: AnyEncodable(data)))
        return addTaskClosure.map { $0(type, AnyEncodable(data)) } ?? addTaskReturnValue
    }

    // MARK: - run

    /// Number of times the function was called.
    public private(set) var runCallsCount = 0
    /// `true` if the function was ever called.
    public var runCalled: Bool {
        runCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var runReceivedArguments: (() -> Void)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var runReceivedInvocations: [() -> Void] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var runClosure: ((() -> Void) -> Void)?

    /// Mocked function for `run(onComplete: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func run(onComplete: @escaping () -> Void) {
        mockCalled = true
        runCallsCount += 1
        runReceivedArguments = onComplete
        runReceivedInvocations.append(onComplete)
        runClosure?(onComplete)
    }
}

/**
 Class to easily create a mocked version of the `QueueRequestManager` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class QueueRequestManagerMock: QueueRequestManager, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        requestCompleteCallsCount = 0
        startRequestCallsCount = 0
        startRequestReceivedArguments = nil
        startRequestReceivedInvocations = []
    }

    // MARK: - requestComplete

    /// Number of times the function was called.
    public private(set) var requestCompleteCallsCount = 0
    /// `true` if the function was ever called.
    public var requestCompleteCalled: Bool {
        requestCompleteCallsCount > 0
    }

    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var requestCompleteClosure: (() -> Void)?

    /// Mocked function for `requestComplete()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func requestComplete() {
        mockCalled = true
        requestCompleteCallsCount += 1
        requestCompleteClosure?()
    }

    // MARK: - startRequest

    /// Number of times the function was called.
    public private(set) var startRequestCallsCount = 0
    /// `true` if the function was ever called.
    public var startRequestCalled: Bool {
        startRequestCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var startRequestReceivedArguments: (() -> Void)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var startRequestReceivedInvocations: [() -> Void] = []
    /// Value to return from the mocked function.
    public var startRequestReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `startRequestReturnValue`
     */
    public var startRequestClosure: ((() -> Void) -> Bool)?

    /// Mocked function for `startRequest(onComplete: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func startRequest(onComplete: @escaping () -> Void) -> Bool {
        mockCalled = true
        startRequestCallsCount += 1
        startRequestReceivedArguments = onComplete
        startRequestReceivedInvocations.append(onComplete)
        return startRequestClosure.map { $0(onComplete) } ?? startRequestReturnValue
    }
}

/**
 Class to easily create a mocked version of the `QueueRunRequest` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class QueueRunRequestMock: QueueRunRequest, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        startCallsCount = 0
        startReceivedArguments = nil
        startReceivedInvocations = []
    }

    // MARK: - start

    /// Number of times the function was called.
    public private(set) var startCallsCount = 0
    /// `true` if the function was ever called.
    public var startCalled: Bool {
        startCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var startReceivedArguments: (() -> Void)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var startReceivedInvocations: [() -> Void] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var startClosure: ((() -> Void) -> Void)?

    /// Mocked function for `start(onComplete: @escaping () -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func start(onComplete: @escaping () -> Void) {
        mockCalled = true
        startCallsCount += 1
        startReceivedArguments = onComplete
        startReceivedInvocations.append(onComplete)
        startClosure?(onComplete)
    }
}

/**
 Class to easily create a mocked version of the `QueueRunner` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class QueueRunnerMock: QueueRunner, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        runTaskCallsCount = 0
        runTaskReceivedArguments = nil
        runTaskReceivedInvocations = []
    }

    // MARK: - runTask

    /// Number of times the function was called.
    public private(set) var runTaskCallsCount = 0
    /// `true` if the function was ever called.
    public var runTaskCalled: Bool {
        runTaskCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var runTaskReceivedArguments: (task: QueueTask,
                                                       onComplete: (Result<Void, CustomerIOError>) -> Void)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var runTaskReceivedInvocations: [(task: QueueTask,
                                                          onComplete: (Result<Void, CustomerIOError>) -> Void)] = []
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     */
    public var runTaskClosure: ((QueueTask, (Result<Void, CustomerIOError>) -> Void) -> Void)?

    /// Mocked function for `runTask(_ task: QueueTask, onComplete: @escaping (Result<Void, CustomerIOError>) -> Void)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func runTask(_ task: QueueTask, onComplete: @escaping (Result<Void, CustomerIOError>) -> Void) {
        mockCalled = true
        runTaskCallsCount += 1
        runTaskReceivedArguments = (task: task, onComplete: onComplete)
        runTaskReceivedInvocations.append((task: task, onComplete: onComplete))
        runTaskClosure?(task, onComplete)
    }
}

/**
 Class to easily create a mocked version of the `QueueStorage` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class QueueStorageMock: QueueStorage, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false

        getInventoryCallsCount = 0
        saveInventoryCallsCount = 0
        saveInventoryReceivedArguments = nil
        saveInventoryReceivedInvocations = []
        createCallsCount = 0
        createReceivedArguments = nil
        createReceivedInvocations = []
        updateCallsCount = 0
        updateReceivedArguments = nil
        updateReceivedInvocations = []
        getCallsCount = 0
        getReceivedArguments = nil
        getReceivedInvocations = []
        deleteCallsCount = 0
        deleteReceivedArguments = nil
        deleteReceivedInvocations = []
    }

    // MARK: - getInventory

    /// Number of times the function was called.
    public private(set) var getInventoryCallsCount = 0
    /// `true` if the function was ever called.
    public var getInventoryCalled: Bool {
        getInventoryCallsCount > 0
    }

    /// Value to return from the mocked function.
    public var getInventoryReturnValue: [QueueTaskMetadata]!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getInventoryReturnValue`
     */
    public var getInventoryClosure: (() -> [QueueTaskMetadata])?

    /// Mocked function for `getInventory()`. Your opportunity to return a mocked value and check result of mock in test code.
    public func getInventory() -> [QueueTaskMetadata] {
        mockCalled = true
        getInventoryCallsCount += 1
        return getInventoryClosure.map { $0() } ?? getInventoryReturnValue
    }

    // MARK: - saveInventory

    /// Number of times the function was called.
    public private(set) var saveInventoryCallsCount = 0
    /// `true` if the function was ever called.
    public var saveInventoryCalled: Bool {
        saveInventoryCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var saveInventoryReceivedArguments: ([QueueTaskMetadata])?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var saveInventoryReceivedInvocations: [[QueueTaskMetadata]] = []
    /// Value to return from the mocked function.
    public var saveInventoryReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `saveInventoryReturnValue`
     */
    public var saveInventoryClosure: (([QueueTaskMetadata]) -> Bool)?

    /// Mocked function for `saveInventory(_ inventory: [QueueTaskMetadata])`. Your opportunity to return a mocked value and check result of mock in test code.
    public func saveInventory(_ inventory: [QueueTaskMetadata]) -> Bool {
        mockCalled = true
        saveInventoryCallsCount += 1
        saveInventoryReceivedArguments = inventory
        saveInventoryReceivedInvocations.append(inventory)
        return saveInventoryClosure.map { $0(inventory) } ?? saveInventoryReturnValue
    }

    // MARK: - create

    /// Number of times the function was called.
    public private(set) var createCallsCount = 0
    /// `true` if the function was ever called.
    public var createCalled: Bool {
        createCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var createReceivedArguments: (type: QueueTaskType, data: Data)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var createReceivedInvocations: [(type: QueueTaskType, data: Data)] = []
    /// Value to return from the mocked function.
    public var createReturnValue: (success: Bool, queueStatus: QueueStatus)!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `createReturnValue`
     */
    public var createClosure: ((QueueTaskType, Data) -> (success: Bool, queueStatus: QueueStatus))?

    /// Mocked function for `create(type: QueueTaskType, data: Data)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func create(type: QueueTaskType, data: Data) -> (success: Bool, queueStatus: QueueStatus) {
        mockCalled = true
        createCallsCount += 1
        createReceivedArguments = (type: type, data: data)
        createReceivedInvocations.append((type: type, data: data))
        return createClosure.map { $0(type, data) } ?? createReturnValue
    }

    // MARK: - update

    /// Number of times the function was called.
    public private(set) var updateCallsCount = 0
    /// `true` if the function was ever called.
    public var updateCalled: Bool {
        updateCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var updateReceivedArguments: (storageId: String, runResults: QueueTaskRunResults)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var updateReceivedInvocations: [(storageId: String, runResults: QueueTaskRunResults)] = []
    /// Value to return from the mocked function.
    public var updateReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `updateReturnValue`
     */
    public var updateClosure: ((String, QueueTaskRunResults) -> Bool)?

    /// Mocked function for `update(storageId: String, runResults: QueueTaskRunResults)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func update(storageId: String, runResults: QueueTaskRunResults) -> Bool {
        mockCalled = true
        updateCallsCount += 1
        updateReceivedArguments = (storageId: storageId, runResults: runResults)
        updateReceivedInvocations.append((storageId: storageId, runResults: runResults))
        return updateClosure.map { $0(storageId, runResults) } ?? updateReturnValue
    }

    // MARK: - get

    /// Number of times the function was called.
    public private(set) var getCallsCount = 0
    /// `true` if the function was ever called.
    public var getCalled: Bool {
        getCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var getReceivedArguments: (String)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var getReceivedInvocations: [String] = []
    /// Value to return from the mocked function.
    public var getReturnValue: QueueTask?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `getReturnValue`
     */
    public var getClosure: ((String) -> QueueTask?)?

    /// Mocked function for `get(storageId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func get(storageId: String) -> QueueTask? {
        mockCalled = true
        getCallsCount += 1
        getReceivedArguments = storageId
        getReceivedInvocations.append(storageId)
        return getClosure.map { $0(storageId) } ?? getReturnValue
    }

    // MARK: - delete

    /// Number of times the function was called.
    public private(set) var deleteCallsCount = 0
    /// `true` if the function was ever called.
    public var deleteCalled: Bool {
        deleteCallsCount > 0
    }

    /// The arguments from the *last* time the function was called.
    public private(set) var deleteReceivedArguments: (String)?
    /// Arguments from *all* of the times that the function was called.
    public private(set) var deleteReceivedInvocations: [String] = []
    /// Value to return from the mocked function.
    public var deleteReturnValue: Bool!
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `deleteReturnValue`
     */
    public var deleteClosure: ((String) -> Bool)?

    /// Mocked function for `delete(storageId: String)`. Your opportunity to return a mocked value and check result of mock in test code.
    public func delete(storageId: String) -> Bool {
        mockCalled = true
        deleteCallsCount += 1
        deleteReceivedArguments = storageId
        deleteReceivedInvocations.append(storageId)
        return deleteClosure.map { $0(storageId) } ?? deleteReturnValue
    }
}

/**
 Class to easily create a mocked version of the `SdkConfigStore` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class SdkConfigStoreMock: SdkConfigStore, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    public var underlyingConfig: SdkConfig!
    /// `true` if the getter or setter of property is called at least once.
    public var configCalled = false
    /// `true` if the getter called on the property at least once.
    public var configGetCalled = false
    /// `true` if the setter called on the property at least once.
    public var configSetCalled = false
    /// The mocked property with a getter and setter.
    public var config: SdkConfig {
        get {
            mockCalled = true
            configCalled = true
            configGetCalled = true
            return underlyingConfig
        }
        set(value) {
            mockCalled = true
            configCalled = true
            configSetCalled = true
            underlyingConfig = value
        }
    }

    public func reset() {
        mockCalled = false

        configCalled = false
        configGetCalled = false
        configSetCalled = false
    }
}

/**
 Class to easily create a mocked version of the `SdkCredentialsStore` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
internal class SdkCredentialsStoreMock: SdkCredentialsStore, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    internal var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    /**
     When setter of the property called, the value given to setter is set here.
     When the getter of the property called, the value set here will be returned. Your chance to mock the property.
     */
    internal var underlyingCredentials: SdkCredentials!
    /// `true` if the getter or setter of property is called at least once.
    internal var credentialsCalled = false
    /// `true` if the getter called on the property at least once.
    internal var credentialsGetCalled = false
    /// `true` if the setter called on the property at least once.
    internal var credentialsSetCalled = false
    /// The mocked property with a getter and setter.
    internal var credentials: SdkCredentials {
        get {
            mockCalled = true
            credentialsCalled = true
            credentialsGetCalled = true
            return underlyingCredentials
        }
        set(value) {
            mockCalled = true
            credentialsCalled = true
            credentialsSetCalled = true
            underlyingCredentials = value
        }
    }

    public func reset() {
        mockCalled = false

        credentialsCalled = false
        credentialsGetCalled = false
        credentialsSetCalled = false
        loadCallsCount = 0
    }

    // MARK: - load

    /// Number of times the function was called.
    internal private(set) var loadCallsCount = 0
    /// `true` if the function was ever called.
    internal var loadCalled: Bool {
        loadCallsCount > 0
    }

    /// Value to return from the mocked function.
    internal var loadReturnValue: SdkCredentials?
    /**
     Set closure to get called when function gets called. Great way to test logic or return a value for the function.
     The closure has first priority to return a value for the mocked function. If the closure returns `nil`,
     then the mock will attempt to return the value for `loadReturnValue`
     */
    internal var loadClosure: (() -> SdkCredentials?)?

    /// Mocked function for `load()`. Your opportunity to return a mocked value and check result of mock in test code.
    internal func load() -> SdkCredentials? {
        mockCalled = true
        loadCallsCount += 1
        return loadClosure.map { $0() } ?? loadReturnValue
    }
}

/**
 Class to easily create a mocked version of the `TrackingInstance` class.
 This class is equipped with functions and properties ready for you to mock!

 Note: This file is automatically generated. This means the mocks should always be up-to-date and has a consistent API.
 See the SDK documentation to learn the basics behind using the mock classes in the SDK.
 */
public class TrackingInstanceMock: TrackingInstance, TrackingMock {
    /// If *any* interactions done on mock. `true` if any method or property getter/setter called.
    public var mockCalled: Bool = false //

    init() {
        TrackingMocks.shared.add(mock: self)
    }

    public func reset() {
        mockCalled = false
    }
}
